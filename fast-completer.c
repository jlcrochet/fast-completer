/*
 * fast-completer - Universal fast completion provider for CLI tools
 *
 * Usage: fast-completer [options] <format> <spans...>
 *
 * This program reads completion data from a binary blob file generated by
 * generate_blob.c, allowing a single completer binary to work with any CLI.
 *
 * The CLI name is derived from the first span and used to look up
 * <name>.fcmpb in the cache directory. Use --blob to specify an explicit path.
 *
 * The last span triggers completions:
 *   "" - subcommands + flags
 *   "-" or "--*" - flags only
 *   "abc..." - matching subcommands
 *
 * Output formats:
 *   lines, zsh, tsv, json, pwsh
 *   Aliases: bash -> lines, fish -> tsv
 */

#include <errno.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "generate_blob.h"

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#else
#include <fcntl.h>
#include <poll.h>
#include <signal.h>
#include <spawn.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#endif

// Supported output formats
typedef enum {
    OUT_LINES,
    OUT_ZSH,
    OUT_TSV,
    OUT_JSON,
    OUT_PWSH,
    OUT_UNKNOWN
} OutputFormat;

// Completion types (for PowerShell)
typedef enum {
    COMP_COMMAND = 2,
    COMP_PARAM_NAME = 7,
    COMP_PARAM_VALUE = 8
} CompletionType;

// String with known length
typedef struct { const char *p; size_t n; } String;

// Create String from string literal
#define STR_LIT(s) ((String){s, sizeof(s) - 1})

// Packed structs matching binary format
#pragma pack(push, 1)
typedef struct {
    uint32_t name_off;
    uint32_t short_off;    // 0 if none, else offset into string table
    uint32_t desc_off;
    uint32_t choices_off;  // 0 if none, else absolute offset into blob
    uint8_t  flags;        // FLAG_TAKES_VALUE, FLAG_IS_MEMBERS
} Param;

typedef struct {
    uint32_t name_off;
    uint32_t desc_off;
    uint32_t params_idx;
    uint16_t subcommands_idx;
    uint16_t params_count;
    uint16_t subcommands_count;
} Command;
#pragma pack(pop)

// Blob header (parsed at load time - only fields actually used)
typedef struct {
    uint32_t max_command_path_len;
    uint32_t string_table_off;
    uint32_t commands_off;
    uint32_t params_off;
    uint32_t root_command_off;
} BlobHeader;

// Global state
static const uint8_t *blob = NULL;
static BlobHeader header;
static OutputFormat output_format;
static bool has_descriptions = true;  // Set from blob flags
static bool add_trailing_space = false;  // Add trailing space to completion values
static bool full_commands = false;       // Complete full leaf command paths instead of next level

// Working buffers (allocated based on header values)
static char *path_buf = NULL;

// Completion context (set once per complete() call)
static const char **g_spans = NULL;
static size_t *g_arg_lens = NULL;
static int g_span_count = 0;

// Hash set for O(1) used-param lookups (lazily built only when completing params)
#define USED_SET_SIZE 256  // Power of 2, must be > 2*MAX_SPANS
typedef struct { const char *p; size_t n; } UsedEntry;
static UsedEntry g_used_set[USED_SET_SIZE];
static bool g_used_set_ready = false;

static inline uint32_t hash_str(const char *p, size_t n) {
    uint32_t h = 5381;
    for (size_t i = 0; i < n; i++) h = ((h << 5) + h) ^ (uint8_t)p[i];
    return h;
}

static void used_set_build(void) {
    if (g_used_set_ready) return;
    memset(g_used_set, 0, sizeof(g_used_set));
    for (int i = 0; i < g_span_count; i++) {
        if (g_spans[i][0] == '-') {
            size_t n = g_arg_lens[i];
            size_t idx = hash_str(g_spans[i], n) & (USED_SET_SIZE - 1);
            while (g_used_set[idx].p) {
                idx = (idx + 1) & (USED_SET_SIZE - 1);
            }
            g_used_set[idx].p = g_spans[i];
            g_used_set[idx].n = n;
        }
    }
    g_used_set_ready = true;
}

static bool used_set_contains(const char *p, size_t n) {
    size_t idx = hash_str(p, n) & (USED_SET_SIZE - 1);
    while (g_used_set[idx].p) {
        if (g_used_set[idx].n == n && memcmp(g_used_set[idx].p, p, n) == 0) return true;
        idx = (idx + 1) & (USED_SET_SIZE - 1);
    }
    return false;
}

// Accessor macros
#define PARAM_TAKES_VALUE(p)   ((p)->flags & FLAG_TAKES_VALUE)
#define PARAM_IS_MEMBERS(p)    ((p)->flags & FLAG_IS_MEMBERS)
#define PARAM_IS_COMPLETER(p)  ((p)->flags & FLAG_IS_COMPLETER)
#define PARAM_HAS_CHOICES(p)   ((p)->choices_off && !((p)->flags & (FLAG_IS_MEMBERS | FLAG_IS_COMPLETER)))
#define PARAM_HAS_MEMBERS(p)   ((p)->choices_off && ((p)->flags & FLAG_IS_MEMBERS))
#define PARAM_HAS_COMPLETER(p) ((p)->choices_off && ((p)->flags & FLAG_IS_COMPLETER))

// Get string from string table
static inline String str_get(uint32_t off) {
    String s;
    if (off == 0) {
        s.p = "";
        s.n = 0;
        return s;
    }
    const uint8_t *p = blob + header.string_table_off + off;
    if (p[0] < 128) {
        s.n = p[0];
        s.p = (const char *)(p + 1);
    } else {
        s.n = ((p[0] & 0x7f) << 8) | p[1];
        s.p = (const char *)(p + 2);
    }
    return s;
}

// Get command by index
static inline const Command *get_command(uint32_t idx) {
    return (const Command *)(blob + header.commands_off + idx * COMMAND_SIZE);
}

// Get param by index
static inline const Param *get_param(uint32_t idx) {
    return (const Param *)(blob + header.params_off + idx * PARAM_SIZE);
}

// Get root command
static inline const Command *get_root_command(void) {
    return (const Command *)(blob + header.root_command_off);
}

// Get command's params (NULL if none)
static inline const Param *cmd_params(const Command *cmd) {
    return cmd->params_count ? get_param(cmd->params_idx) : NULL;
}

// Get command's subcommands (NULL if none)
static inline const Command *cmd_subcommands(const Command *cmd) {
    return cmd->subcommands_count ? get_command(cmd->subcommands_idx) : NULL;
}

// Read variable-length count-prefixed array of string offsets
// Format: u8 count if <255, else 0xFF + u16 count, then count * u32 offsets
static inline uint16_t get_string_list_count(uint32_t off) {
    uint8_t first = blob[off];
    if (first < 255) return first;
    return *(const uint16_t *)(blob + off + 1);
}

static inline const uint32_t *get_string_offsets(uint32_t off) {
    uint8_t first = blob[off];
    return (const uint32_t *)(blob + off + (first < 255 ? 1 : 3));
}

// Track if we've started the JSON array
static bool json_started = false;

static inline bool needs_trailing_space(String s) {
    return s.n > 0 && s.p[s.n - 1] != '=';
}

// I/O helpers
#if defined(_MSC_VER)
// MSVC: use _nolock variants
static inline void put_char(int c) {
    _putc_nolock(c, stdout);
}
static inline void put_bytes(const char *p, size_t n) {
    _fwrite_nolock(p, 1, n, stdout);
}
#define flockfile(f) _lock_file(f)
#define funlockfile(f) _unlock_file(f)
#elif defined(_WIN32)
// MinGW: use standard functions (no unlocked variants)
static inline void put_char(int c) {
    putc(c, stdout);
}
static inline void put_bytes(const char *p, size_t n) {
    fwrite(p, 1, n, stdout);
}
#define flockfile(f) (void)(f)
#define funlockfile(f) (void)(f)
#elif defined(__APPLE__)
// macOS: no fwrite_unlocked
static inline void put_char(int c) {
    putc_unlocked(c, stdout);
}
#define put_bytes(p, n) fwrite(p, 1, n, stdout)
#else
// Linux/other Unix: use unlocked variants
static inline void put_char(int c) {
    putc_unlocked(c, stdout);
}
static inline void put_bytes(const char *p, size_t n) {
    fwrite_unlocked(p, 1, n, stdout);
}
#endif

#define put_lit(s) put_bytes(s, sizeof(s) - 1)

static inline void put_str(String s) {
    put_bytes(s.p, s.n);
}

// JSON string escaping
static void print_json_str_inner(String s) {
    static const char hex[] = "0123456789abcdef";
    for (size_t i = 0; i < s.n; i++) {
        switch (s.p[i]) {
            case '"':  put_lit("\\\""); break;
            case '\\': put_lit("\\\\"); break;
            case '\n': put_lit("\\n"); break;
            case '\r': put_lit("\\r"); break;
            case '\t': put_lit("\\t"); break;
            default:
                if ((unsigned char)s.p[i] < 32) {
                    put_lit("\\u00");
                    put_char(hex[(unsigned char)s.p[i] >> 4]);
                    put_char(hex[(unsigned char)s.p[i] & 0xf]);
                } else {
                    put_char(s.p[i]);
                }
        }
    }
}

static void print_json_str(String s) {
    put_char('"');
    print_json_str_inner(s);
    put_char('"');
}

static void print_json_str_with_space(String s) {
    put_char('"');
    print_json_str_inner(s);
    put_char(' ');
    put_char('"');
}

// Output a completion item
static void output_completion(String value, String desc, CompletionType type) {
    switch (output_format) {
    case OUT_JSON:
        if (json_started) put_char(',');
        json_started = true;
        put_char('{');
        print_json_str(STR_LIT("value"));
        put_char(':');
        if (add_trailing_space && needs_trailing_space(value))
            print_json_str_with_space(value);
        else
            print_json_str(value);
        if (desc.n > 0) {
            put_char(',');
            print_json_str(STR_LIT("description"));
            put_char(':');
            print_json_str(desc);
        }
        put_char('}');
        break;

    case OUT_TSV:
        put_str(value);
        if (add_trailing_space && needs_trailing_space(value))
            put_char(' ');
        if (desc.n > 0) {
            put_char('\t');
            put_str(desc);
        }
        put_char('\n');
        break;

    case OUT_ZSH:
        put_str(value);
        if (add_trailing_space && needs_trailing_space(value))
            put_char(' ');
        if (desc.n > 0) {
            put_char(':');
            for (size_t i = 0; i < desc.n; i++) {
                if (desc.p[i] == '\\') put_char('\\');  // escape backslashes
                put_char(desc.p[i]);
            }
        }
        put_char('\n');
        break;

    case OUT_LINES:
        put_str(value);
        if (add_trailing_space && needs_trailing_space(value))
            put_char(' ');
        put_char('\n');
        break;

    case OUT_PWSH:
        put_str(value);
        if (add_trailing_space && needs_trailing_space(value))
            put_char(' ');
        put_char('\t');
        put_str(value);
        put_char('\t');
        put_char('0' + type);
        put_char('\t');
        put_str(desc.n > 0 ? desc : value);
        put_char('\n');
        break;

    case OUT_UNKNOWN:
        break;  // Should never happen
    }
}

// Compare strings lexicographically (for binary search)
static inline int str_cmp(const char *a, size_t a_len, const char *b, size_t b_len) {
    size_t min_len = (a_len < b_len) ? a_len : b_len;
    int cmp = memcmp(a, b, min_len);
    if (cmp != 0) return cmp;
    return (a_len < b_len) ? -1 : (a_len > b_len) ? 1 : 0;
}

// Binary search for a command by name among sorted subcommands
static const Command *bsearch_command(const Command *subs, uint16_t count, const char *name, size_t name_len) {
    uint16_t lo = 0, hi = count;
    while (lo < hi) {
        uint16_t mid = lo + (hi - lo) / 2;
        String s = str_get(subs[mid].name_off);
        int cmp = str_cmp(s.p, s.n, name, name_len);
        if (cmp < 0) lo = mid + 1;
        else if (cmp > 0) hi = mid;
        else return &subs[mid];
    }
    return NULL;
}

// Maximum command path depth (root -> ... -> leaf)
#define MAX_CMD_DEPTH 32

// Command path from root to deepest match (for param inheritance)
static const Command *g_cmd_path[MAX_CMD_DEPTH];
static int g_cmd_path_len = 0;

// Find the deepest matching command, tracking the path
static const Command *find_command(void) {
    g_cmd_path_len = 0;
    const Command *cmd = get_root_command();
    g_cmd_path[g_cmd_path_len++] = cmd;
    int i = 1;  // Skip first arg (CLI name)

    while (i < g_span_count && cmd->subcommands_count > 0) {
        const char *arg = g_spans[i];

        if (arg[0] == '-') {
            i++;
            continue;
        }

        size_t arg_len = g_arg_lens[i];
        const Command *found = bsearch_command(cmd_subcommands(cmd), cmd->subcommands_count, arg, arg_len);

        if (found) {
            cmd = found;
            if (g_cmd_path_len < MAX_CMD_DEPTH) {
                g_cmd_path[g_cmd_path_len++] = cmd;
            }
            i++;
        } else {
            break;
        }
    }

    return cmd;
}

// Check if a parameter has already been used (by long or short name)
// Uses hash set for O(1) lookup instead of O(spans) linear scan
static bool param_used(const Param *param) {
    used_set_build();  // Lazy init on first call
    String name = str_get(param->name_off);
    if (name.n > 0 && used_set_contains(name.p, name.n)) return true;
    if (param->short_off) {
        String short_opt = str_get(param->short_off);
        if (used_set_contains(short_opt.p, short_opt.n)) return true;
    }
    return false;
}

// Pre-computed prefix analysis for parameter completion
typedef struct {
    size_t len;
    bool is_dash;         // starts with -
    bool is_double_dash;  // starts with --
    bool is_single_dash;  // starts with - but not --
} PrefixInfo;

static inline PrefixInfo make_prefix_info(const char *prefix, size_t len) {
    PrefixInfo info = {0};
    if (prefix && len > 0) {
        info.len = len;
        info.is_dash = prefix[0] == '-';
        info.is_double_dash = len >= 2 && prefix[0] == '-' && prefix[1] == '-';
        info.is_single_dash = info.is_dash && !info.is_double_dash;
    }
    return info;
}

// Recursively output leaf commands
static void complete_leaf_commands(const Command *cmd, String path, const char *prefix, size_t prefix_len) {
    if (cmd->subcommands_count == 0) return;

    char *buf = path_buf;
    const Command *subs = cmd_subcommands(cmd);

    for (uint16_t i = 0; i < cmd->subcommands_count; i++) {
        const Command *sub = &subs[i];
        String sub_name = str_get(sub->name_off);

        size_t new_len;
        if (path.n > 0) {
            if (path.n + 1 + sub_name.n >= header.max_command_path_len) continue;
            buf[path.n] = ' ';
            memcpy(buf + path.n + 1, sub_name.p, sub_name.n);
            new_len = path.n + 1 + sub_name.n;
        } else {
            if (sub_name.n >= header.max_command_path_len) continue;
            memcpy(buf, sub_name.p, sub_name.n);
            new_len = sub_name.n;
        }
        buf[new_len] = '\0';

        bool matches = !prefix || strncmp(buf, prefix, prefix_len) == 0;

        if (sub->subcommands_count > 0) {
            if (!prefix || matches || strncmp(prefix, buf, new_len) == 0) {
                complete_leaf_commands(sub, (String){buf, new_len}, prefix, prefix_len);
            }
        } else if (matches) {
            uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : sub->desc_off;
            output_completion((String){buf, new_len}, str_get(desc), COMP_COMMAND);
        }

        buf[path.n] = '\0';
    }
}

// Binary search for first subcommand with name >= prefix (lower bound)
static uint16_t bsearch_prefix_lower(const Command *subs, uint16_t count,
                                      const char *prefix, size_t prefix_len) {
    uint16_t lo = 0, hi = count;
    while (lo < hi) {
        uint16_t mid = lo + (hi - lo) / 2;
        String s = str_get(subs[mid].name_off);
        size_t cmp_len = (s.n < prefix_len) ? s.n : prefix_len;
        int cmp = memcmp(s.p, prefix, cmp_len);
        if (cmp < 0 || (cmp == 0 && s.n < prefix_len)) {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }
    return lo;
}

// Complete immediate subcommands (single level)
// Uses binary search for prefix matching: O(log n + matches) instead of O(n)
static void complete_next_level(const Command *cmd, const char *prefix, size_t prefix_len) {
    if (cmd->subcommands_count == 0) return;

    const Command *subs = cmd_subcommands(cmd);

    // No prefix: output all subcommands
    if (!prefix || prefix_len == 0) {
        for (uint16_t i = 0; i < cmd->subcommands_count; i++) {
            const Command *sub = &subs[i];
            String name = str_get(sub->name_off);
            uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : sub->desc_off;
            output_completion(name, str_get(desc), COMP_COMMAND);
        }
        return;
    }

    // Binary search for first match, then iterate while prefix matches
    uint16_t start = bsearch_prefix_lower(subs, cmd->subcommands_count, prefix, prefix_len);
    for (uint16_t i = start; i < cmd->subcommands_count; i++) {
        const Command *sub = &subs[i];
        String name = str_get(sub->name_off);
        if (name.n < prefix_len || memcmp(name.p, prefix, prefix_len) != 0) break;
        uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : sub->desc_off;
        output_completion(name, str_get(desc), COMP_COMMAND);
    }
}

// Complete subcommands (full leaf paths or next level based on flag)
static void complete_subcommands(const Command *cmd, const char *prefix, size_t prefix_len) {
    if (full_commands) {
        path_buf[0] = '\0';
        complete_leaf_commands(cmd, (String){path_buf, 0}, prefix, prefix_len);
    } else {
        complete_next_level(cmd, prefix, prefix_len);
    }
}

// Complete parameters from a param list
static void complete_params_list(const Param *params, uint16_t params_count,
                                  const char *prefix, const PrefixInfo *pinfo) {
    if (!params || params_count == 0) return;
    if (pinfo->len > 0 && !pinfo->is_dash) return;

    // When prefix is "-" (single dash only), show short options first
    if (pinfo->is_single_dash) {
        for (uint16_t i = 0; i < params_count; i++) {
            const Param *p = &params[i];
            if (p->short_off == 0) continue;
            if (param_used(p)) continue;

            String short_opt = str_get(p->short_off);
            if (short_opt.n >= pinfo->len && memcmp(short_opt.p, prefix, pinfo->len) == 0) {
                uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : p->desc_off;
                output_completion(short_opt, str_get(desc), COMP_PARAM_NAME);
            }
        }
    }

    // Show long options (always, unless prefix is single dash with more chars like "-x")
    if (!pinfo->is_single_dash || pinfo->len == 1) {
        for (uint16_t i = 0; i < params_count; i++) {
            const Param *p = &params[i];
            if (param_used(p)) continue;

            String name = str_get(p->name_off);
            if (name.n == 0) continue;  // Skip short-only params
            if (pinfo->len == 0 || (name.n >= pinfo->len && memcmp(name.p, prefix, pinfo->len) == 0)) {
                uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : p->desc_off;
                output_completion(name, str_get(desc), COMP_PARAM_NAME);
            }
        }
    }
}

// Complete string list at a blob offset (choices or members)
static void complete_string_list(uint32_t off, const char *prefix, size_t prefix_len) {
    if (off == 0) return;

    uint16_t count = get_string_list_count(off);
    const uint32_t *offsets = get_string_offsets(off);

    for (uint16_t i = 0; i < count; i++) {
        String s = str_get(offsets[i]);
        if (!prefix || (s.n >= prefix_len && memcmp(s.p, prefix, prefix_len) == 0)) {
            output_completion(s, str_get(0), COMP_PARAM_VALUE);
        }
    }
}

// Split command string into argv array (simple space splitting)
// Returns argc, fills argv (must have room for max_args+1 entries, last is NULL)
static int split_args(char *cmd, char **argv, int max_args) {
    int argc = 0;
    char *p = cmd;
    while (*p && argc < max_args) {
        while (*p == ' ') p++;  // Skip spaces
        if (!*p) break;
        argv[argc++] = p;
        while (*p && *p != ' ') p++;  // Find end of arg
        if (*p) *p++ = '\0';  // Null-terminate
    }
    argv[argc] = NULL;
    return argc;
}

// Execute a dynamic completer command and output results
// cli_name: CLI name (e.g., "az") from g_spans[0]
// completer: subcommand args (e.g., "aks get-versions --output tsv") - String with length
// prefix: optional prefix to filter results
// prefix_len: length of prefix
static void execute_completer(const char *cli_name, String completer,
                               const char *prefix, size_t prefix_len) {
    if (!cli_name || !completer.p || completer.n == 0) return;

    // Build argument string: copy completer (need mutable string for splitting)
    char *args = malloc(completer.n + 1);
    if (!args) return;
    memcpy(args, completer.p, completer.n);
    args[completer.n] = '\0';

    // Split into argv: [cli_name, arg1, arg2, ..., NULL]
    char *argv[64];
    argv[0] = (char *)cli_name;
    split_args(args, argv + 1, 62);

#ifdef _WIN32
    // Windows implementation using overlapped I/O with direct exec (no cmd.exe shell)
    // Note: No cleanup needed - process exits after completion, OS reclaims all resources

    // Build command line string from argv for CreateProcess
    // Format: "cli arg1 arg2 ..." (CreateProcess expects space-separated)
    size_t cmdline_len = strlen(cli_name) + 1 + completer.n + 1;
    char *cmdline = malloc(cmdline_len);
    if (!cmdline) return;
    snprintf(cmdline, cmdline_len, "%s %.*s", cli_name, (int)completer.n, completer.p);

    // Create named pipe with FILE_FLAG_OVERLAPPED for async reads
    char pipe_name[256];
    snprintf(pipe_name, sizeof(pipe_name), "\\\\.\\pipe\\fc_%lu_%lu",
             (unsigned long)GetCurrentProcessId(), (unsigned long)GetTickCount());

    HANDLE stdout_read = CreateNamedPipeA(
        pipe_name, PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_BYTE | PIPE_WAIT, 1, 4096, 4096, 0, NULL);
    if (stdout_read == INVALID_HANDLE_VALUE) return;

    SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
    HANDLE stdout_write = CreateFileA(pipe_name, GENERIC_WRITE, 0, &sa, OPEN_EXISTING, 0, NULL);
    if (stdout_write == INVALID_HANDLE_VALUE) return;

    STARTUPINFOA si = {0};
    si.cb = sizeof(STARTUPINFOA);
    si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    si.hStdOutput = stdout_write;
    si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
    si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    si.wShowWindow = SW_HIDE;

    PROCESS_INFORMATION pi = {0};
    if (!CreateProcessA(NULL, cmdline, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) return;
    CloseHandle(stdout_write);  // Child has it, close so reads see EOF when child exits

    // Overlapped read setup
    OVERLAPPED ov = {0};
    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!ov.hEvent) { TerminateProcess(pi.hProcess, 1); return; }

    char line[4096];
    size_t line_pos = 0;
    char buf[4096];
    DWORD bytes_read;
    ULONGLONG start_time = GetTickCount64();
    HANDLE wait_handles[2] = {ov.hEvent, pi.hProcess};

    while (1) {
        ULONGLONG elapsed = GetTickCount64() - start_time;
        DWORD remaining = (elapsed >= 2000) ? 0 : (2000 - elapsed);

        ResetEvent(ov.hEvent);
        BOOL read_ok = ReadFile(stdout_read, buf, sizeof(buf), &bytes_read, &ov);
        DWORD err = GetLastError();

        if (!read_ok && err == ERROR_IO_PENDING) {
            DWORD wait = WaitForMultipleObjects(2, wait_handles, FALSE, remaining);
            if (wait == WAIT_OBJECT_0) {
                if (!GetOverlappedResult(stdout_read, &ov, &bytes_read, FALSE)) break;
            } else if (wait == WAIT_OBJECT_0 + 1) {
                CancelIo(stdout_read);
                if (!GetOverlappedResult(stdout_read, &ov, &bytes_read, FALSE) || bytes_read == 0) break;
            } else {
                CancelIo(stdout_read);
                TerminateProcess(pi.hProcess, 1);
                break;
            }
        } else if (!read_ok) {
            break;
        }

        for (DWORD i = 0; i < bytes_read; i++) {
            if (buf[i] == '\n' || buf[i] == '\r') {
                if (line_pos > 0) {
                    line[line_pos] = '\0';
                    if (!prefix || (line_pos >= prefix_len && memcmp(line, prefix, prefix_len) == 0)) {
                        output_completion((String){line, line_pos}, str_get(0), COMP_PARAM_VALUE);
                    }
                    line_pos = 0;
                }
            } else if (line_pos < sizeof(line) - 1) {
                line[line_pos++] = buf[i];
            }
        }
    }

    if (line_pos > 0) {
        line[line_pos] = '\0';
        if (!prefix || (line_pos >= prefix_len && memcmp(line, prefix, prefix_len) == 0)) {
            output_completion((String){line, line_pos}, str_get(0), COMP_PARAM_VALUE);
        }
    }
#else
    // Unix implementation using posix_spawnp with direct exec (no shell)
    int pipefd[2];
    if (pipe(pipefd) < 0) return;

    posix_spawn_file_actions_t actions;
    posix_spawn_file_actions_init(&actions);
    posix_spawn_file_actions_addclose(&actions, pipefd[0]);
    posix_spawn_file_actions_adddup2(&actions, pipefd[1], STDOUT_FILENO);
    posix_spawn_file_actions_addclose(&actions, pipefd[1]);
    posix_spawn_file_actions_addopen(&actions, STDERR_FILENO, "/dev/null", O_WRONLY, 0);

    extern char **environ;
    pid_t pid;
    if (posix_spawnp(&pid, cli_name, &actions, NULL, argv, environ) != 0) return;
    close(pipefd[1]);  // Close write end so reads see EOF when child exits

    // Non-blocking reads with poll() timeout
    fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) | O_NONBLOCK);

    char line[4096];
    size_t line_pos = 0;
    char buf[4096];
    struct timespec start, now;
    clock_gettime(CLOCK_MONOTONIC, &start);
    int timeout_ms = 2000;

    while (timeout_ms > 0) {
        struct pollfd pfd = { .fd = pipefd[0], .events = POLLIN };
        if (poll(&pfd, 1, timeout_ms) <= 0) break;

        ssize_t n = read(pipefd[0], buf, sizeof(buf));
        if (n <= 0) break;

        for (ssize_t i = 0; i < n; i++) {
            if (buf[i] == '\n') {
                if (line_pos > 0) {
                    line[line_pos] = '\0';
                    if (!prefix || (line_pos >= prefix_len && memcmp(line, prefix, prefix_len) == 0)) {
                        output_completion((String){line, line_pos}, str_get(0), COMP_PARAM_VALUE);
                    }
                    line_pos = 0;
                }
            } else if (line_pos < sizeof(line) - 1) {
                line[line_pos++] = buf[i];
            }
        }

        // Update remaining timeout
        clock_gettime(CLOCK_MONOTONIC, &now);
        int elapsed_ms = (now.tv_sec - start.tv_sec) * 1000 + (now.tv_nsec - start.tv_nsec) / 1000000;
        timeout_ms = 2000 - elapsed_ms;
    }

    if (line_pos > 0) {
        line[line_pos] = '\0';
        if (!prefix || (line_pos >= prefix_len && memcmp(line, prefix, prefix_len) == 0)) {
            output_completion((String){line, line_pos}, str_get(0), COMP_PARAM_VALUE);
        }
    }

    if (waitpid(pid, NULL, WNOHANG) == 0) {
        kill(pid, SIGKILL);
        waitpid(pid, NULL, 0);  // Reap zombie
    }
#endif
}

// Find a parameter by name (long or short option) using linear search
// Linear search is used because we must check both long AND short names,
// and typical param count per command is small (< 10)
static const Param *find_param(const Param *params, uint16_t params_count, const char *opt, size_t opt_len) {
    if (!params || params_count == 0 || !opt) return NULL;
    if (opt[0] != '-') return NULL;

    bool is_short = (opt_len == 2 && opt[0] == '-' && opt[1] != '-');

    for (uint16_t i = 0; i < params_count; i++) {
        // Check long option
        String s = str_get(params[i].name_off);
        if (s.n == opt_len && memcmp(s.p, opt, opt_len) == 0)
            return &params[i];

        // Check short option
        if (is_short && params[i].short_off) {
            String short_opt = str_get(params[i].short_off);
            if (short_opt.n == opt_len && memcmp(short_opt.p, opt, opt_len) == 0)
                return &params[i];
        }
    }
    return NULL;
}

// Complete params from entire command path (deepest first for relevance)
static void complete_path_params(const char *prefix, const PrefixInfo *pinfo) {
    for (int i = g_cmd_path_len - 1; i >= 0; i--) {
        const Command *cmd = g_cmd_path[i];
        complete_params_list(cmd_params(cmd), cmd->params_count, prefix, pinfo);
    }
}

// Find a param by name across entire command path (deepest first for override semantics)
static const Param *find_path_param(const char *opt, size_t opt_len) {
    for (int i = g_cmd_path_len - 1; i >= 0; i--) {
        const Command *cmd = g_cmd_path[i];
        const Param *p = find_param(cmd_params(cmd), cmd->params_count, opt, opt_len);
        if (p) return p;
    }
    return NULL;
}

// Check if span is empty/whitespace
static inline bool is_new_arg(const char *span) {
    if (!span || !*span) return true;
    // Fast path: if first char is not whitespace, it's not a new arg
    if (span[0] != ' ' && span[0] != '\t') return false;
    // Slow path: check remaining chars for non-whitespace
    for (const char *p = span + 1; *p; p++) {
        if (*p != ' ' && *p != '\t') return false;
    }
    return true;
}

// Parse output format - uses first char + length for fast dispatch
static OutputFormat parse_format(const char *name) {
    size_t len = strlen(name);
    // Quick dispatch on first char and length
    switch (name[0]) {
    case 'b':
        if (len == 4 && memcmp(name, "bash", 4) == 0) return OUT_LINES;
        break;
    case 'f':
        if (len == 4 && memcmp(name, "fish", 4) == 0) return OUT_TSV;
        break;
    case 'j':
        if (len == 4 && memcmp(name, "json", 4) == 0) return OUT_JSON;
        break;
    case 'l':
        if (len == 5 && memcmp(name, "lines", 5) == 0) return OUT_LINES;
        break;
    case 'p':
        if (len == 4 && memcmp(name, "pwsh", 4) == 0) return OUT_PWSH;
        if (len == 10 && memcmp(name, "powershell", 10) == 0) return OUT_PWSH;
        break;
    case 't':
        if (len == 3 && memcmp(name, "tsv", 3) == 0) return OUT_TSV;
        break;
    case 'z':
        if (len == 3 && memcmp(name, "zsh", 3) == 0) return OUT_ZSH;
        break;
    }
    return OUT_UNKNOWN;
}

// Maximum spans we support (command lines rarely exceed this)
#define MAX_SPANS 128

// Main completion logic
static void complete(int nspans, const char **spans) {
    if (nspans == 0) {
        if (output_format == OUT_JSON) put_lit("[]\n");
        return;
    }

    // Fail if too many spans
    if (nspans > MAX_SPANS) {
        fprintf(stderr, "Too many arguments (%d > %d)\n", nspans, MAX_SPANS);
        exit(1);
    }

    // Pre-compute all arg lengths once and set globals (fixed-size to avoid VLA)
    // Exploit contiguous argv layout (works on Linux, macOS, Windows, BSDs)
    size_t arg_lens[MAX_SPANS];
    for (int i = 0; i < nspans - 1; i++) {
        arg_lens[i] = (size_t)(spans[i + 1] - spans[i] - 1);
    }
    arg_lens[nspans - 1] = strlen(spans[nspans - 1]);
    g_spans = spans;
    g_arg_lens = arg_lens;
    g_span_count = nspans > 1 ? nspans - 1 : 1;
    g_used_set_ready = false;  // Reset for lazy init

    // Find the deepest matching command
    const Command *cmd = find_command();

    if (output_format == OUT_JSON) put_char('[');

    const char *last_span = spans[nspans - 1];
    size_t last_span_len = arg_lens[nspans - 1];
    bool is_empty = is_new_arg(last_span);
    bool is_flag_prefix = last_span[0] == '-';
    char c = last_span[0];
    bool is_cmd_prefix = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');

    if (is_flag_prefix) {
        PrefixInfo pinfo = make_prefix_info(last_span, last_span_len);
        complete_path_params(last_span, &pinfo);
        if (output_format == OUT_JSON) put_lit("]\n");
        return;
    }

    if (is_cmd_prefix) {
        if (cmd->subcommands_count > 0) {
            complete_subcommands(cmd, last_span, last_span_len);
        }
        if (output_format == OUT_JSON) put_lit("]\n");
        return;
    }

    if (!is_empty) {
        if (output_format == OUT_JSON) put_lit("]\n");
        return;
    }

    const char *prev_arg = g_span_count > 0 ? spans[g_span_count - 1] : "";

    if (prev_arg[0] == '-') {
        size_t prev_len = arg_lens[g_span_count - 1];

        const Param *param = find_path_param(prev_arg, prev_len);
        if (param && PARAM_TAKES_VALUE(param)) {
            if (PARAM_HAS_CHOICES(param)) {
                complete_string_list(param->choices_off, NULL, 0);
            } else if (PARAM_HAS_MEMBERS(param)) {
                complete_string_list(param->choices_off, NULL, 0);
            } else if (PARAM_HAS_COMPLETER(param)) {
                execute_completer(g_spans[0], str_get(param->choices_off), NULL, 0);
            }
            if (output_format == OUT_JSON) put_lit("]\n");
            return;
        }
    }

    if (cmd->subcommands_count > 0) {
        complete_subcommands(cmd, NULL, 0);
    }

    PrefixInfo pinfo = {0};  // Empty prefix
    complete_path_params(NULL, &pinfo);

    if (output_format == OUT_JSON) put_lit("]\n");
}

// Load and validate blob file
static bool load_blob(const char *path) {
#ifdef _WIN32
    HANDLE fh = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fh == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "%s: %lu\n", path, GetLastError());
        return false;
    }

    LARGE_INTEGER size;
    if (!GetFileSizeEx(fh, &size)) {
        fprintf(stderr, "GetFileSizeEx: %lu\n", GetLastError());
        return false;
    }
    size_t blob_size = (size_t)size.QuadPart;

    if (blob_size < HEADER_SIZE) {
        fprintf(stderr, "%s: file too small\n", path);
        return false;
    }

    HANDLE mapping = CreateFileMappingA(fh, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!mapping) {
        fprintf(stderr, "CreateFileMapping: %lu\n", GetLastError());
        return false;
    }

    blob = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
    if (!blob) {
        fprintf(stderr, "MapViewOfFile: %lu\n", GetLastError());
        CloseHandle(mapping);
        CloseHandle(fh);
        return false;
    }
    CloseHandle(mapping);  // Mapping remains valid until UnmapViewOfFile
    CloseHandle(fh);       // File handle no longer needed
#else
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror(path);
        return false;
    }

    struct stat st;
    if (fstat(fd, &st) < 0) {
        perror("fstat");
        return false;
    }

    size_t blob_size = st.st_size;
    if (blob_size < HEADER_SIZE) {
        fprintf(stderr, "%s: file too small\n", path);
        return false;
    }

    blob = mmap(NULL, blob_size, PROT_READ, MAP_PRIVATE, fd, 0);
    close(fd);  // fd no longer needed after mmap
    if (blob == MAP_FAILED) {
        perror("mmap");
        blob = NULL;
        return false;
    }
#endif

    // Validate magic
    if (memcmp(blob, BLOB_MAGIC, 4) != 0) {
        fprintf(stderr, "%s: invalid magic\n", path);
        return false;
    }

    // Check endianness compatibility BEFORE reading other fields
    // Big-endian blobs store flags as [0x00, 0x01] at offset 6-7
    // Little-endian blobs store flags as [0x00, 0x00] at offset 6-7
    bool blob_is_big_endian = (blob[6] == 0x00 && blob[7] == 0x01);
    bool system_is_big_endian = (*(uint16_t *)"\0\1" == 1);
    if (blob_is_big_endian != system_is_big_endian) {
        fprintf(stderr, "%s: endianness mismatch (blob is %s-endian, system is %s-endian)\n",
                path,
                blob_is_big_endian ? "big" : "little",
                system_is_big_endian ? "big" : "little");
        return false;
    }

    // Validate version (now safe to read as native endianness)
    uint16_t version = *(uint16_t *)(blob + 4);
    if (version != BLOB_VERSION) {
        fprintf(stderr, "%s: unsupported version %d (expected %d)\n", path, version, BLOB_VERSION);
        return false;
    }

    // Check if blob has descriptions
    uint16_t flags = *(uint16_t *)(blob + 6);
    has_descriptions = !(flags & HEADER_FLAG_NO_DESCRIPTIONS);

    // Parse header (skip magic:4, version:2, flags:2 = offset 8)
    const uint32_t *h = (const uint32_t *)(blob + 8);
    header.max_command_path_len = h[0];
    // h[1]-h[5] are counts/sizes (used by dump_blob.py, not runtime)
    header.string_table_off = h[6];
    header.commands_off = h[7];
    header.params_off = h[8];
    // h[9]-h[10] are choices_off, members_off (used by dump_blob.py)
    header.root_command_off = h[11];

    return true;
}


// --------------------------------------------------------------------------
// Cache directory management
// --------------------------------------------------------------------------

// Get cache directory path
static char *get_cache_dir(void) {
    // Check for custom cache directory
    const char *custom = getenv("FAST_COMPLETER_CACHE");
    if (custom && *custom) {
        return strdup(custom);
    }

    // Fall back to platform-specific default
    char *dir = NULL;

#ifdef _WIN32
    const char *localappdata = getenv("LOCALAPPDATA");
    if (localappdata) {
        size_t len = strlen(localappdata) + 20;
        dir = malloc(len);
        snprintf(dir, len, "%s\\fast-completer", localappdata);
    }
#else
    const char *home = getenv("HOME");
    if (home) {
        size_t len = strlen(home) + 30;
        dir = malloc(len);
        snprintf(dir, len, "%s/.cache/fast-completer", home);
    }
#endif

    return dir;
}

// Create cache directory if it doesn't exist
static bool ensure_cache_dir(void) {
    char *cache_dir = get_cache_dir();
    if (!cache_dir) return false;

#ifdef _WIN32
    // Create fast-completer directory under %LOCALAPPDATA%
    if (!CreateDirectoryA(cache_dir, NULL) && GetLastError() != ERROR_ALREADY_EXISTS) {
        fprintf(stderr, "Failed to create cache directory: %s (error %lu)\n", cache_dir, GetLastError());
        return false;
    }
#else
    // Create ~/.cache if needed, then ~/.cache/fast-completer
    char *parent = strdup(cache_dir);
    char *last_slash = strrchr(parent, '/');
    if (last_slash) {
        *last_slash = '\0';
        if (mkdir(parent, 0755) != 0 && errno != EEXIST) {
            fprintf(stderr, "Failed to create parent directory: %s: %s\n", parent, strerror(errno));
            return false;
        }
    }
    if (mkdir(cache_dir, 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Failed to create cache directory: %s: %s\n", cache_dir, strerror(errno));
        return false;
    }
#endif

    return true;
}

// Build full blob path in cache directory
static char *build_cache_path(const char *name) {
    char *cache_dir = get_cache_dir();
    if (!cache_dir) return NULL;

    size_t len = strlen(cache_dir) + strlen(name) + 10;
    char *path = malloc(len);
#ifdef _WIN32
    snprintf(path, len, "%s\\%s.fcmpb", cache_dir, name);
#else
    snprintf(path, len, "%s/%s.fcmpb", cache_dir, name);
#endif

    return path;
}

// Check if path looks like a simple name (no slashes)
static bool is_simple_name(const char *path) {
    while (*path) {
        if (*path == '/' || *path == '\\') return false;
        path++;
    }
    return true;
}

// Resolve blob path: if simple name, look in cache; otherwise use as-is
static char *resolve_blob_path(const char *blob_arg) {
    // If it contains path separators, use as-is
    if (!is_simple_name(blob_arg)) {
        return strdup(blob_arg);
    }

    // Strip .fcmpb extension if present
    char *name = strdup(blob_arg);
    size_t len = strlen(name);
    if (len > 6 && strcmp(name + len - 6, ".fcmpb") == 0) {
        name[len - 6] = '\0';
    }

    char *path = build_cache_path(name);
    return path;
}

// Dump blob header for debugging
static void dump_header(const char *path) {
    const uint32_t *h = (const uint32_t *)(blob + 8);
    uint16_t version = *(uint16_t *)(blob + 4);
    uint16_t flags = *(uint16_t *)(blob + 6);

    printf("path: %s\n", path);
    printf("magic: %.4s\n", (const char *)blob);
    printf("version: %u\n", version);
    printf("flags: %u", flags);
    if (flags) {
        printf(" (");
        if (flags & HEADER_FLAG_BIG_ENDIAN) printf("big_endian");
        if (flags & HEADER_FLAG_NO_DESCRIPTIONS) {
            if (flags & HEADER_FLAG_BIG_ENDIAN) printf(", ");
            printf("no_descriptions");
        }
        printf(")");
    }
    printf("\n");
    printf("max_command_path_len: %u\n", h[0]);
    printf("command_count: %u\n", h[1]);
    printf("param_count: %u\n", h[2]);
    printf("string_table_size: %u\n", h[3]);
    printf("choices_count: %u\n", h[4]);
    printf("members_count: %u\n", h[5]);
    printf("string_table_off: %u\n", h[6]);
    printf("commands_off: %u\n", h[7]);
    printf("params_off: %u\n", h[8]);
    printf("choices_off: %u\n", h[9]);
    printf("members_off: %u\n", h[10]);
    printf("root_command_off: %u\n", h[11]);
}

static void print_help(void) {
    puts("fast-completer - Universal fast completion provider\n");
    puts("Usage: fast-completer [options] <format> <spans...>");
    puts("       fast-completer --generate-blob <schema> [output]");
    puts("       fast-completer --check <name>");
    puts("       fast-completer --dump-header <blob>\n");
    puts("Completion mode:");
    puts("  fast-completer [options] <format> <spans...>\n");
    puts("  format        Output format (see below)");
    puts("  spans         Command line tokens starting with CLI name\n");
    puts("  --blob <path>    Use blob at specified path instead of cache lookup");
    puts("  --add-space      Append trailing space to completion values");
    puts("  --full-commands  Complete full leaf command paths instead of next level");
    puts("  --quiet, -q      Suppress errors if blob not found (for fallback scripts)\n");
    puts("  The CLI name is derived from the first span and used to look up");
    puts("  <name>.fcmpb in the cache directory.\n");
    puts("  Cache location (override with FAST_COMPLETER_CACHE env var):");
#ifdef _WIN32
    puts("    %LOCALAPPDATA%\\fast-completer\\<name>.fcmpb");
#else
    puts("    ~/.cache/fast-completer/<name>.fcmpb");
#endif
    puts("");
    puts("Blob generation mode:");
    puts("  fast-completer --generate-blob [options] <schema> [output]\n");
    puts("  schema               Path to schema file");
    puts("  output               Output path (optional - defaults to cache directory)");
    puts("  --big-endian         Generate big-endian blob");
    puts("  --no-descriptions    Omit descriptions entirely (smallest blob)");
    puts("  --short-descriptions First sentence only (default)");
    puts("  --long-descriptions  Include full descriptions");
    puts("  --description-length <n>  Truncate descriptions to n characters\n");
    puts("  Description options can be combined: --long-descriptions --description-length 200");
    puts("  will include full descriptions but truncate any exceeding 200 characters.");
    puts("  If output is omitted, reads 'name' from schema and saves to cache.\n");
    puts("Check mode:");
    puts("  fast-completer --check <name>\n");
    puts("  name              CLI name to check (e.g., 'aws')");
    puts("  Returns exit code 0 if blob exists in cache, 1 otherwise.\n");
    puts("Dump header mode:");
    puts("  fast-completer --dump-header <blob>\n");
    puts("  blob              Path or cache name (e.g., 'aws' or '/path/to/aws.fcmpb')\n");
    puts("Output formats:");
    puts("  bash, lines       One value per line (no descriptions)");
    puts("  zsh               value:description");
    puts("  fish, tsv         value\\tdescription");
    puts("  pwsh              PowerShell format");
    puts("  json              JSON array of {\"value\": ..., \"description\": ...}\n");
    puts("Use 'lines' format when descriptions are not needed.\n");
    puts("Examples:");
    puts("  fast-completer --generate-blob aws.fcmps");
    puts("      Generate blob from schema (CLI name derived from first command)\n");
    puts("  fast-completer --check aws && echo 'aws completions available'");
    puts("      Conditionally run command if aws blob exists\n");
    puts("  fast-completer bash aws s3 \"\"");
    puts("      Complete subcommands after 'aws s3'\n");
    puts("  fast-completer --blob /path/to/custom.fcmpb zsh mycli --");
    puts("      Complete flags using explicit blob path\n");
    puts("  fast-completer --dump-header aws");
    puts("      Dump header of cached aws.fcmpb blob");
}

int main(int argc, char *argv[]) {
    // Pre-scan for --quiet/-q to redirect stderr early
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--quiet") == 0 || strcmp(argv[i], "-q") == 0) {
#ifdef _WIN32
            if (!freopen("NUL", "w", stderr)) _exit(1);
#else
            if (!freopen("/dev/null", "w", stderr)) _exit(1);
#endif
            break;
        }
        // Stop scanning at first non-option argument
        if (argv[i][0] != '-') break;
    }

    if (argc >= 2 && (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0)) {
        print_help();
        return 0;
    }

    // Handle --check mode: test if blob exists in cache
    if (argc >= 2 && strcmp(argv[1], "--check") == 0) {
        if (argc < 3) {
            fprintf(stderr, "Usage: fast-completer --check <name>\n");
            return 1;
        }
        char *path = resolve_blob_path(argv[2]);
        if (!path) return 1;
#ifdef _WIN32
        DWORD attrs = GetFileAttributesA(path);
        return (attrs != INVALID_FILE_ATTRIBUTES) ? 0 : 1;
#else
        struct stat st;
        return (stat(path, &st) == 0) ? 0 : 1;
#endif
    }

    // Handle --dump-header mode
    if (argc >= 2 && strcmp(argv[1], "--dump-header") == 0) {
        if (argc < 3) {
            fprintf(stderr, "Usage: fast-completer --dump-header <blob>\n");
            return 1;
        }
        char *path = resolve_blob_path(argv[2]);
        if (!load_blob(path)) {
            return 1;
        }
        dump_header(path);
        return 0;
    }

    // Handle --generate-blob mode (must come first)
    if (argc >= 2 && strcmp(argv[1], "--generate-blob") == 0) {
        bool big_endian = false;
        DescriptionMode desc_mode = DESC_SHORT;  // Default: first sentence only
        size_t desc_max_len = 0;  // 0 = unlimited
        int arg_idx = 2;

        // Parse options (last one wins for description mode)
        while (argc > arg_idx && argv[arg_idx][0] == '-') {
            if (strcmp(argv[arg_idx], "--big-endian") == 0) {
                big_endian = true;
            } else if (strcmp(argv[arg_idx], "--no-descriptions") == 0) {
                desc_mode = DESC_NONE;
            } else if (strcmp(argv[arg_idx], "--short-descriptions") == 0) {
                desc_mode = DESC_SHORT;
            } else if (strcmp(argv[arg_idx], "--long-descriptions") == 0) {
                desc_mode = DESC_LONG;
            } else if (strcmp(argv[arg_idx], "--description-length") == 0) {
                if (argc <= arg_idx + 1) {
                    fprintf(stderr, "--description-length requires a value\n");
                    return 1;
                }
                char *endptr;
                unsigned long val = strtoul(argv[arg_idx + 1], &endptr, 10);
                if (*endptr != '\0' || val < 4) {
                    fprintf(stderr, "--description-length must be an integer >= 4\n");
                    return 1;
                }
                desc_max_len = (size_t)val;
                arg_idx++;
            } else {
                break;
            }
            arg_idx++;
        }

        if (argc < arg_idx + 1) {
            fprintf(stderr, "Usage: fast-completer --generate-blob [options] <schema> [output]\n");
            fprintf(stderr, "Options: --big-endian, --no-descriptions, --short-descriptions, --long-descriptions, --description-length <n>\n");
            return 1;
        }

        const char *schema_path = argv[arg_idx];
        const char *output_path = (argc > arg_idx + 1) ? argv[arg_idx + 1] : NULL;
        char *derived_path = NULL;

        // If no output path, derive from schema's "name" property
        if (!output_path) {
            char *name = get_schema_name(schema_path);
            if (!name) {
                fprintf(stderr, "Schema must have 'name' property when output path is omitted\n");
                return 1;
            }
            ensure_cache_dir();
            derived_path = build_cache_path(name);
            output_path = derived_path;
        }

        bool result = generate_blob(schema_path, output_path, big_endian, desc_mode, desc_max_len);
        return result ? 0 : 1;
    }

    // Parse completion mode arguments
    int arg_idx = 1;
    const char *explicit_blob_path = NULL;

    // Check for options
    while (argc > arg_idx && argv[arg_idx][0] == '-' && argv[arg_idx][1] == '-') {
        if (argc > arg_idx + 1 && strcmp(argv[arg_idx], "--blob") == 0) {
            explicit_blob_path = argv[arg_idx + 1];
            arg_idx += 2;
        } else if (strcmp(argv[arg_idx], "--add-space") == 0) {
            add_trailing_space = true;
            arg_idx++;
        } else if (strcmp(argv[arg_idx], "--full-commands") == 0) {
            full_commands = true;
            arg_idx++;
        } else if (strcmp(argv[arg_idx], "--quiet") == 0 || strcmp(argv[arg_idx], "-q") == 0) {
            arg_idx++;  // Already handled by pre-scan
        } else {
            break;
        }
    }

    if (argc < arg_idx + 2) {
        fprintf(stderr, "Usage: fast-completer [options] <format> <spans...>\n");
        fprintf(stderr, "Try 'fast-completer --help' for more information.\n");
        return 1;
    }

    const char *format_name = argv[arg_idx];
    int spans_start = arg_idx + 1;
    const char *cli_name = argv[spans_start]; // Derive from first span

    // Resolve blob path
    char *resolved_path = NULL;
    const char *blob_path;
    if (explicit_blob_path) {
        blob_path = explicit_blob_path;
    } else {
        resolved_path = resolve_blob_path(cli_name);
        blob_path = resolved_path;
    }

    output_format = parse_format(format_name);
    if (output_format == OUT_UNKNOWN) {
        fprintf(stderr, "Unknown output format: %s\n", format_name);
        fprintf(stderr, "Supported: lines, zsh, tsv, json, pwsh\n");
        return 1;
    }

    if (!load_blob(blob_path)) {
        // If cache lookup failed, show helpful error
        if (!explicit_blob_path && is_simple_name(cli_name)) {
            char *cache_dir = get_cache_dir();
            fprintf(stderr, "Blob '%s' not found in %s\n", cli_name, cache_dir ? cache_dir : "(unknown)");
            fprintf(stderr, "Generate it with: fast-completer --generate-blob <schema>\n");
        }
        return 1;
    }

    // Allocate path buffer only when needed for --full-commands
    if (full_commands) {
        path_buf = malloc(header.max_command_path_len);
        if (!path_buf) {
            perror("malloc");
            return 1;
        }
    }

    flockfile(stdout);
    complete(argc - spans_start, (const char **)(argv + spans_start));
    funlockfile(stdout);

    return 0;
}
