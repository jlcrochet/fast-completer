/*
 * fast-completer - Universal fast completion provider for CLI tools
 *
 * Usage: fast-completer <blob> <output> <spans...>
 *
 * This program reads completion data from a binary blob file generated by
 * generate_blob.c, allowing a single completer binary to work with any CLI.
 *
 * The last span triggers completions:
 *   "" - subcommands + flags
 *   "-" or "--*" - flags only
 *   "abc..." - matching subcommands
 *
 * Output formats:
 *   lines, zsh, tsv, json, json-tuple, msgpack, msgpack-tuple, pwsh
 *   Aliases: bash -> lines, fish -> tsv, nushell -> msgpack
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "generate_blob.h"

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#else
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

// Blob format constants (must match generate_blob.c)
#define BLOB_MAGIC "FCMP"
#define BLOB_VERSION 2
#define HEADER_SIZE 68
#define PARAM_SIZE 17
#define COMMAND_SIZE 16

// Param flags
#define FLAG_TAKES_VALUE 0x01
#define FLAG_IS_MEMBERS  0x02

// Header flags
#define HEADER_FLAG_BIG_ENDIAN 0x01

// Supported output formats
typedef enum {
    OUT_LINES,
    OUT_ZSH,
    OUT_TSV,
    OUT_JSON,
    OUT_JSON_TUPLE,
    OUT_MSGPACK,
    OUT_MSGPACK_TUPLE,
    OUT_PWSH,
    OUT_UNKNOWN
} OutputFormat;

// Completion types (for PowerShell)
typedef enum {
    COMP_COMMAND = 2,
    COMP_PARAM_NAME = 7,
    COMP_PARAM_VALUE = 8
} CompletionType;

// String with known length
typedef struct { const char *p; size_t n; } String;

// Create String from string literal
#define STR_LIT(s) ((String){s, sizeof(s) - 1})

// Packed structs matching binary format
#pragma pack(push, 1)
typedef struct {
    uint32_t name_off;
    uint32_t short_off;    // 0 if none, else offset into string table
    uint32_t desc_off;
    uint32_t choices_off;  // 0 if none, else absolute offset into blob
    uint8_t  flags;        // FLAG_TAKES_VALUE, FLAG_IS_MEMBERS
} Param;

typedef struct {
    uint32_t name_off;
    uint32_t desc_off;
    uint32_t params_idx;
    uint32_t subcommands_idx;
} Command;
#pragma pack(pop)

// Blob header (parsed at load time - only fields actually used)
typedef struct {
    uint32_t max_command_path_len;
    uint32_t msgpack_buffer_size;
    uint32_t string_table_off;
    uint32_t commands_off;
    uint32_t params_off;
    uint32_t global_params_off;
    uint32_t root_command_off;
} BlobHeader;

// Global state
static const uint8_t *blob = NULL;
static BlobHeader header;
static OutputFormat output_format;

// Working buffers (allocated based on header values)
static uint8_t *msgpack_buf = NULL;
static size_t msgpack_len = 0;
static uint32_t msgpack_count = 0;
static char *path_buf = NULL;

// Accessor macros
#define PARAM_TAKES_VALUE(p) ((p)->flags & FLAG_TAKES_VALUE)
#define PARAM_IS_MEMBERS(p)  ((p)->flags & FLAG_IS_MEMBERS)
#define PARAM_HAS_CHOICES(p) (!PARAM_IS_MEMBERS(p) && (p)->choices_off != 0)
#define PARAM_HAS_MEMBERS(p) (PARAM_IS_MEMBERS(p) && (p)->choices_off != 0)

// Get string from string table
static inline String str_get(uint32_t off) {
    String s;
    if (off == 0) {
        s.p = "";
        s.n = 0;
        return s;
    }
    const uint8_t *p = blob + header.string_table_off + off;
    if (p[0] < 128) {
        s.n = p[0];
        s.p = (const char *)(p + 1);
    } else {
        s.n = ((p[0] & 0x7f) << 8) | p[1];
        s.p = (const char *)(p + 2);
    }
    return s;
}

// Check if string table entry is empty (sentinel)
static inline bool str_empty(uint32_t off) {
    if (off == 0) return true;
    return blob[header.string_table_off + off] == 0;
}

// Compare string table entry with C string
static inline bool str_eq(uint32_t off, const char *cstr) {
    String s = str_get(off);
    size_t clen = strlen(cstr);
    return s.n == clen && memcmp(s.p, cstr, clen) == 0;
}

// Get command by index
static inline const Command *get_command(uint32_t idx) {
    return (const Command *)(blob + header.commands_off + idx * COMMAND_SIZE);
}

// Get param by index
static inline const Param *get_param(uint32_t idx) {
    return (const Param *)(blob + header.params_off + idx * PARAM_SIZE);
}

// Get root command
static inline const Command *get_root_command(void) {
    return (const Command *)(blob + header.root_command_off);
}

// Get global params array
static inline const Param *get_global_params(void) {
    return (const Param *)(blob + header.global_params_off);
}

// Get command's params (NULL if none)
static inline const Param *cmd_params(const Command *cmd) {
    return cmd->params_idx ? get_param(cmd->params_idx) : NULL;
}

// Get command's subcommands (NULL if none)
static inline const Command *cmd_subcommands(const Command *cmd) {
    return cmd->subcommands_idx ? get_command(cmd->subcommands_idx) : NULL;
}

// Read null-terminated array of string offsets at blob offset
static inline const uint32_t *get_string_offsets(uint32_t off) {
    return (const uint32_t *)(blob + off);
}

// Track if we've started the JSON array
static bool json_started = false;

// MessagePack helpers
static void msgpack_write_byte(uint8_t b) {
    msgpack_buf[msgpack_len++] = b;
}

static void msgpack_write_bytes(const void *data, size_t len) {
    memcpy(msgpack_buf + msgpack_len, data, len);
    msgpack_len += len;
}

static void msgpack_write_str(String s) {
    if (s.n <= 31) {
        msgpack_write_byte(0xa0 | (uint8_t)s.n);
    } else if (s.n <= 255) {
        msgpack_write_byte(0xd9);
        msgpack_write_byte((uint8_t)s.n);
    } else if (s.n <= 65535) {
        msgpack_write_byte(0xda);
        uint8_t buf[2] = { (uint8_t)(s.n >> 8), (uint8_t)s.n };
        msgpack_write_bytes(buf, 2);
    } else {
        msgpack_write_byte(0xdb);
        uint8_t buf[4] = { (uint8_t)(s.n >> 24), (uint8_t)(s.n >> 16),
                          (uint8_t)(s.n >> 8), (uint8_t)s.n };
        msgpack_write_bytes(buf, 4);
    }
    msgpack_write_bytes(s.p, s.n);
}

// I/O helpers
#ifdef _WIN32
#define put_char(c) putchar(c)
#define put_bytes(p, n) fwrite(p, 1, n, stdout)
#define flockfile(f) ((void)0)
#define funlockfile(f) ((void)0)
#else
static inline void put_char(int c) {
    putc_unlocked(c, stdout);
}
#ifdef __APPLE__
#define put_bytes(p, n) fwrite(p, 1, n, stdout)
#else
static inline void put_bytes(const char *p, size_t n) {
    fwrite_unlocked(p, 1, n, stdout);
}
#endif
#endif

#define put_lit(s) put_bytes(s, sizeof(s) - 1)

static inline void put_str(String s) {
    put_bytes(s.p, s.n);
}

// JSON string escaping
static void print_json_str(String s) {
    static const char hex[] = "0123456789abcdef";
    put_char('"');
    for (size_t i = 0; i < s.n; i++) {
        switch (s.p[i]) {
            case '"':  put_lit("\\\""); break;
            case '\\': put_lit("\\\\"); break;
            case '\n': put_lit("\\n"); break;
            case '\r': put_lit("\\r"); break;
            case '\t': put_lit("\\t"); break;
            default:
                if ((unsigned char)s.p[i] < 32) {
                    put_lit("\\u00");
                    put_char(hex[(unsigned char)s.p[i] >> 4]);
                    put_char(hex[(unsigned char)s.p[i] & 0xf]);
                } else {
                    put_char(s.p[i]);
                }
        }
    }
    put_char('"');
}

// Output a completion item
static void output_completion(String value, String desc, CompletionType type) {
    switch (output_format) {
    case OUT_JSON:
        if (json_started) put_char(',');
        json_started = true;
        put_char('{');
        print_json_str(STR_LIT("value"));
        put_char(':');
        print_json_str(value);
        if (desc.n > 0) {
            put_char(',');
            print_json_str(STR_LIT("description"));
            put_char(':');
            print_json_str(desc);
        }
        put_char('}');
        break;

    case OUT_TSV:
        put_str(value);
        if (desc.n > 0) {
            put_char('\t');
            put_str(desc);
        }
        put_char('\n');
        break;

    case OUT_ZSH:
        put_str(value);
        if (desc.n > 0) {
            put_char(':');
            for (size_t i = 0; i < desc.n; i++) {
                if (desc.p[i] == ':' || desc.p[i] == '\\') put_char('\\');
                put_char(desc.p[i]);
            }
        }
        put_char('\n');
        break;

    case OUT_LINES:
        put_str(value);
        put_char('\n');
        break;

    case OUT_PWSH:
        put_str(value);
        put_char('\t');
        put_str(value);
        put_char('\t');
        put_char('0' + type);
        put_char('\t');
        put_str(desc.n > 0 ? desc : value);
        put_char('\n');
        break;

    case OUT_JSON_TUPLE:
        if (json_started) put_char(',');
        json_started = true;
        put_char('[');
        print_json_str(value);
        put_char(',');
        print_json_str(desc);
        put_char(']');
        break;

    case OUT_MSGPACK:
        msgpack_write_byte(desc.n > 0 ? 0x82 : 0x81);
        msgpack_write_str(STR_LIT("value"));
        msgpack_write_str(value);
        if (desc.n > 0) {
            msgpack_write_str(STR_LIT("description"));
            msgpack_write_str(desc);
        }
        msgpack_count++;
        break;

    case OUT_MSGPACK_TUPLE:
        msgpack_write_byte(0x92);
        msgpack_write_str(value);
        msgpack_write_str(desc);
        msgpack_count++;
        break;

    default:
        put_str(value);
        put_char('\n');
        break;
    }
}

// Find the deepest matching command
static const Command *find_command(const char **args, int argc) {
    const Command *cmd = get_root_command();
    int i = 1;  // Skip first arg (CLI name)

    while (i < argc && cmd_subcommands(cmd)) {
        const char *arg = args[i];

        if (arg[0] == '-') {
            i++;
            continue;
        }

        const Command *found = NULL;
        for (const Command *sub = cmd_subcommands(cmd); !str_empty(sub->name_off); sub++) {
            if (str_eq(sub->name_off, arg)) {
                found = sub;
                break;
            }
        }

        if (found) {
            cmd = found;
            i++;
        } else {
            break;
        }
    }

    return cmd;
}

// Check if a parameter has already been used (by long or short name)
static bool param_used(const Param *param, const char **args, int argc) {
    String name = str_get(param->name_off);
    String short_opt = param->short_off ? str_get(param->short_off) : (String){NULL, 0};

    for (int i = 0; i < argc; i++) {
        const char *arg = args[i];
        size_t arg_len = strlen(arg);
        if (arg_len == name.n && memcmp(arg, name.p, name.n) == 0)
            return true;
        if (short_opt.p && arg_len == short_opt.n && memcmp(arg, short_opt.p, short_opt.n) == 0)
            return true;
    }
    return false;
}

// Recursively output leaf commands
static void complete_leaf_commands(const Command *cmd, String path, const char *prefix) {
    if (!cmd_subcommands(cmd)) return;

    char *buf = path_buf;
    size_t prefix_len = prefix ? strlen(prefix) : 0;

    for (const Command *sub = cmd_subcommands(cmd); !str_empty(sub->name_off); sub++) {
        String sub_name = str_get(sub->name_off);

        size_t new_len;
        if (path.n > 0) {
            if (path.n + 1 + sub_name.n >= header.max_command_path_len) continue;
            buf[path.n] = ' ';
            memcpy(buf + path.n + 1, sub_name.p, sub_name.n);
            new_len = path.n + 1 + sub_name.n;
        } else {
            if (sub_name.n >= header.max_command_path_len) continue;
            memcpy(buf, sub_name.p, sub_name.n);
            new_len = sub_name.n;
        }
        buf[new_len] = '\0';

        bool matches = !prefix || strncmp(buf, prefix, prefix_len) == 0;

        if (cmd_subcommands(sub)) {
            if (!prefix || matches || strncmp(prefix, buf, new_len) == 0) {
                complete_leaf_commands(sub, (String){buf, new_len}, prefix);
            }
        } else if (matches) {
            output_completion((String){buf, new_len}, str_get(sub->desc_off), COMP_COMMAND);
        }

        buf[path.n] = '\0';
    }
}

// Complete subcommands (leaf commands only)
static void complete_subcommands(const Command *cmd, const char *prefix) {
    path_buf[0] = '\0';
    complete_leaf_commands(cmd, (String){path_buf, 0}, prefix);
}

// Complete parameters from a param list
static void complete_params_list(const Param *params, const char **args, int argc, const char *prefix) {
    if (!params) return;

    size_t prefix_len = prefix ? strlen(prefix) : 0;
    bool prefix_is_dash = prefix_len >= 1 && prefix[0] == '-';
    bool prefix_is_double_dash = prefix_len >= 2 && prefix[0] == '-' && prefix[1] == '-';
    bool prefix_is_single_dash = prefix_is_dash && !prefix_is_double_dash;

    if (prefix_len > 0 && !prefix_is_dash) return;

    // When prefix is "-" (single dash only), show short options first
    if (prefix_is_single_dash) {
        for (const Param *p = params; !str_empty(p->name_off); p++) {
            if (p->short_off == 0) continue;
            if (param_used(p, args, argc)) continue;

            String short_opt = str_get(p->short_off);
            if (short_opt.n >= prefix_len && memcmp(short_opt.p, prefix, prefix_len) == 0) {
                output_completion(short_opt, str_get(p->desc_off), COMP_PARAM_NAME);
            }
        }
    }

    // Show long options (always, unless prefix is single dash with more chars like "-x")
    if (!prefix_is_single_dash || prefix_len == 1) {
        for (const Param *p = params; !str_empty(p->name_off); p++) {
            if (param_used(p, args, argc)) continue;

            String name = str_get(p->name_off);
            if (prefix_len == 0 || (name.n >= prefix_len && memcmp(name.p, prefix, prefix_len) == 0)) {
                output_completion(name, str_get(p->desc_off), COMP_PARAM_NAME);
            }
        }
    }
}

// Complete global params
static void complete_global_params(const char **args, int argc, const char *prefix) {
    size_t prefix_len = prefix ? strlen(prefix) : 0;
    bool prefix_is_dash = prefix_len >= 1 && prefix[0] == '-';
    bool prefix_is_double_dash = prefix_len >= 2 && prefix[0] == '-' && prefix[1] == '-';
    bool prefix_is_single_dash = prefix_is_dash && !prefix_is_double_dash;

    if (prefix_len > 0 && !prefix_is_dash) return;

    // When prefix is "-" (single dash only), show short options first
    if (prefix_is_single_dash) {
        for (const Param *p = get_global_params(); p->name_off; p++) {
            if (p->short_off == 0) continue;
            if (param_used(p, args, argc)) continue;

            String short_opt = str_get(p->short_off);
            if (short_opt.n >= prefix_len && memcmp(short_opt.p, prefix, prefix_len) == 0) {
                output_completion(short_opt, str_get(p->desc_off), COMP_PARAM_NAME);
            }
        }
    }

    // Show long options
    if (!prefix_is_single_dash || prefix_len == 1) {
        for (const Param *p = get_global_params(); p->name_off; p++) {
            if (param_used(p, args, argc)) continue;

            String name = str_get(p->name_off);
            if (prefix_len == 0 || (name.n >= prefix_len && memcmp(name.p, prefix, prefix_len) == 0)) {
                output_completion(name, str_get(p->desc_off), COMP_PARAM_NAME);
            }
        }
    }
}

// Complete string list at a blob offset (choices or members)
static void complete_string_list(uint32_t off, const char *prefix) {
    if (off == 0) return;

    size_t prefix_len = prefix ? strlen(prefix) : 0;
    const uint32_t *offsets = get_string_offsets(off);

    for (; *offsets; offsets++) {
        String s = str_get(*offsets);
        if (!prefix || (s.n >= prefix_len && memcmp(s.p, prefix, prefix_len) == 0)) {
            output_completion(s, str_get(0), COMP_PARAM_VALUE);
        }
    }
}

// Find a parameter by name (long or short option)
static const Param *find_param(const Param *params, const char *opt) {
    if (!params || !opt) return NULL;
    if (opt[0] != '-') return NULL;

    size_t opt_len = strlen(opt);

    for (const Param *p = params; !str_empty(p->name_off); p++) {
        // Check long option
        if (str_eq(p->name_off, opt)) return p;
        // Check short option
        if (p->short_off) {
            String short_opt = str_get(p->short_off);
            if (short_opt.n == opt_len && memcmp(short_opt.p, opt, opt_len) == 0)
                return p;
        }
    }
    return NULL;
}

// Find a global param by name (long or short option)
static const Param *find_global_param(const char *name, size_t len) {
    for (const Param *p = get_global_params(); p->name_off; p++) {
        // Check long option
        String pname = str_get(p->name_off);
        if (pname.n == len && memcmp(pname.p, name, len) == 0)
            return p;
        // Check short option
        if (p->short_off) {
            String short_opt = str_get(p->short_off);
            if (short_opt.n == len && memcmp(short_opt.p, name, len) == 0)
                return p;
        }
    }
    return NULL;
}

// Check if span is empty/whitespace
static bool is_new_arg(const char *span) {
    if (!span || !*span) return true;
    for (const char *p = span; *p; p++) {
        if (*p != ' ' && *p != '\t') return false;
    }
    return true;
}

// Parse output format
static OutputFormat parse_format(const char *name) {
    if (strcmp(name, "lines") == 0) return OUT_LINES;
    if (strcmp(name, "bash") == 0) return OUT_LINES;
    if (strcmp(name, "zsh") == 0) return OUT_ZSH;
    if (strcmp(name, "tsv") == 0) return OUT_TSV;
    if (strcmp(name, "fish") == 0) return OUT_TSV;
    if (strcmp(name, "json") == 0) return OUT_JSON;
    if (strcmp(name, "json-tuple") == 0) return OUT_JSON_TUPLE;
    if (strcmp(name, "nushell") == 0 || strcmp(name, "nu") == 0) return OUT_MSGPACK;
    if (strcmp(name, "msgpack") == 0) return OUT_MSGPACK;
    if (strcmp(name, "msgpack-tuple") == 0) return OUT_MSGPACK_TUPLE;
    if (strcmp(name, "pwsh") == 0 || strcmp(name, "powershell") == 0) return OUT_PWSH;
    return OUT_UNKNOWN;
}

// Output format header
static void output_header(void) {
    if (output_format == OUT_JSON || output_format == OUT_JSON_TUPLE) {
        put_char('[');
    }
}

// Output format footer
static void output_footer(void) {
    if (output_format == OUT_JSON || output_format == OUT_JSON_TUPLE) {
        put_lit("]\n");
    } else if (output_format == OUT_MSGPACK || output_format == OUT_MSGPACK_TUPLE) {
        uint8_t hdr[5];
        size_t hdr_len;
        if (msgpack_count <= 15) {
            hdr[0] = 0x90 | (uint8_t)msgpack_count;
            hdr_len = 1;
        } else if (msgpack_count <= 65535) {
            hdr[0] = 0xdc;
            hdr[1] = (uint8_t)(msgpack_count >> 8);
            hdr[2] = (uint8_t)msgpack_count;
            hdr_len = 3;
        } else {
            hdr[0] = 0xdd;
            hdr[1] = (uint8_t)(msgpack_count >> 24);
            hdr[2] = (uint8_t)(msgpack_count >> 16);
            hdr[3] = (uint8_t)(msgpack_count >> 8);
            hdr[4] = (uint8_t)msgpack_count;
            hdr_len = 5;
        }
        put_bytes((const char *)hdr, hdr_len);
        if (msgpack_len > 0) {
            put_bytes((const char *)msgpack_buf, msgpack_len);
        }
    }
}

// Main completion logic
static void complete(int nspans, const char **spans) {
    output_header();

    if (nspans == 0) {
        output_footer();
        return;
    }

    const char *last_span = spans[nspans - 1];
    bool is_empty = is_new_arg(last_span);
    bool is_flag_prefix = last_span[0] == '-';
    bool is_cmd_prefix = last_span[0] >= 'a' && last_span[0] <= 'z';

    int search_count = nspans - 1;
    if (search_count < 1) search_count = 1;

    const Command *cmd = find_command(spans, search_count);

    if (is_flag_prefix) {
        complete_params_list(cmd_params(cmd), spans, search_count, last_span);
        complete_global_params(spans, search_count, last_span);
        output_footer();
        return;
    }

    if (is_cmd_prefix) {
        if (cmd_subcommands(cmd)) {
            complete_subcommands(cmd, last_span);
        }
        output_footer();
        return;
    }

    if (!is_empty) {
        output_footer();
        return;
    }

    const char *prev_arg = search_count > 0 ? spans[search_count - 1] : "";

    if (prev_arg[0] == '-') {
        size_t prev_len = strlen(prev_arg);

        const Param *gparam = find_global_param(prev_arg, prev_len);
        if (gparam && PARAM_TAKES_VALUE(gparam)) {
            if (PARAM_HAS_CHOICES(gparam)) {
                complete_string_list(gparam->choices_off, NULL);
            }
            output_footer();
            return;
        }

        const Param *param = find_param(cmd_params(cmd), prev_arg);
        if (param && PARAM_TAKES_VALUE(param)) {
            if (PARAM_HAS_CHOICES(param)) {
                complete_string_list(param->choices_off, NULL);
            } else if (PARAM_HAS_MEMBERS(param)) {
                complete_string_list(param->choices_off, NULL);
            }
            output_footer();
            return;
        }
    }

    if (cmd_subcommands(cmd)) {
        complete_subcommands(cmd, NULL);
    }

    complete_params_list(cmd_params(cmd), spans, search_count, NULL);
    complete_global_params(spans, search_count, NULL);

    output_footer();
}

// Load and validate blob file
static bool load_blob(const char *path) {
#ifdef _WIN32
    HANDLE fh = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fh == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "%s: %lu\n", path, GetLastError());
        return false;
    }

    LARGE_INTEGER size;
    if (!GetFileSizeEx(fh, &size)) {
        fprintf(stderr, "GetFileSizeEx: %lu\n", GetLastError());
        return false;
    }
    size_t blob_size = (size_t)size.QuadPart;

    if (blob_size < HEADER_SIZE) {
        fprintf(stderr, "%s: file too small\n", path);
        return false;
    }

    HANDLE mapping = CreateFileMappingA(fh, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!mapping) {
        fprintf(stderr, "CreateFileMapping: %lu\n", GetLastError());
        return false;
    }

    blob = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
    if (!blob) {
        fprintf(stderr, "MapViewOfFile: %lu\n", GetLastError());
        return false;
    }
#else
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror(path);
        return false;
    }

    struct stat st;
    if (fstat(fd, &st) < 0) {
        perror("fstat");
        return false;
    }

    size_t blob_size = st.st_size;
    if (blob_size < HEADER_SIZE) {
        fprintf(stderr, "%s: file too small\n", path);
        return false;
    }

    blob = mmap(NULL, blob_size, PROT_READ, MAP_PRIVATE, fd, 0);
    close(fd);  // fd no longer needed after mmap
    if (blob == MAP_FAILED) {
        perror("mmap");
        blob = NULL;
        return false;
    }
#endif

    // Validate magic
    if (memcmp(blob, BLOB_MAGIC, 4) != 0) {
        fprintf(stderr, "%s: invalid magic\n", path);
        return false;
    }

    // Check endianness compatibility BEFORE reading other fields
    // Big-endian blobs store flags as [0x00, 0x01] at offset 6-7
    // Little-endian blobs store flags as [0x00, 0x00] at offset 6-7
    bool blob_is_big_endian = (blob[6] == 0x00 && blob[7] == 0x01);
    bool system_is_big_endian = (*(uint16_t *)"\0\1" == 1);
    if (blob_is_big_endian != system_is_big_endian) {
        fprintf(stderr, "%s: endianness mismatch (blob is %s-endian, system is %s-endian)\n",
                path,
                blob_is_big_endian ? "big" : "little",
                system_is_big_endian ? "big" : "little");
        return false;
    }

    // Validate version (now safe to read as native endianness)
    uint16_t version = *(uint16_t *)(blob + 4);
    if (version != BLOB_VERSION) {
        fprintf(stderr, "%s: unsupported version %d (expected %d)\n", path, version, BLOB_VERSION);
        return false;
    }

    // Parse header (skip magic:4, version:2, flags:2 = offset 8)
    const uint32_t *h = (const uint32_t *)(blob + 8);
    header.max_command_path_len = h[0];
    header.msgpack_buffer_size = h[1];
    // h[2]-h[7] are counts (unused at runtime)
    header.string_table_off = h[8];
    header.commands_off = h[9];
    header.params_off = h[10];
    // h[11]-h[12] are choices_off, members_off (accessed via Param.choices_off)
    header.global_params_off = h[13];
    header.root_command_off = h[14];

    return true;
}

// Allocate working buffers based on output format
static bool alloc_buffers(void) {
    // Always need path buffer for subcommand completion
    path_buf = malloc(header.max_command_path_len);
    if (!path_buf) {
        perror("malloc");
        return false;
    }

    // Only allocate msgpack buffer if needed
    if (output_format == OUT_MSGPACK || output_format == OUT_MSGPACK_TUPLE) {
        msgpack_buf = malloc(header.msgpack_buffer_size);
        if (!msgpack_buf) {
            perror("malloc");
            return false;
        }
    }

    return true;
}

// --------------------------------------------------------------------------
// Cache directory management
// --------------------------------------------------------------------------

// Get cache directory path
static char *get_cache_dir(void) {
    // Check for custom cache directory
    const char *custom = getenv("FAST_COMPLETER_CACHE");
    if (custom && *custom) {
        return strdup(custom);
    }

    // Fall back to platform-specific default
    char *dir = NULL;

#ifdef _WIN32
    const char *localappdata = getenv("LOCALAPPDATA");
    if (localappdata) {
        size_t len = strlen(localappdata) + 20;
        dir = malloc(len);
        snprintf(dir, len, "%s\\fast-completer", localappdata);
    }
#else
    const char *home = getenv("HOME");
    if (home) {
        size_t len = strlen(home) + 30;
        dir = malloc(len);
        snprintf(dir, len, "%s/.cache/fast-completer", home);
    }
#endif

    return dir;
}

// Create cache directory if it doesn't exist
static bool ensure_cache_dir(void) {
    char *cache_dir = get_cache_dir();
    if (!cache_dir) return false;

#ifdef _WIN32
    // Create parent .cache dir first, then fast-completer
    CreateDirectoryA(cache_dir, NULL);
#else
    // Create ~/.cache if needed, then ~/.cache/fast-completer
    char *parent = strdup(cache_dir);
    char *last_slash = strrchr(parent, '/');
    if (last_slash) {
        *last_slash = '\0';
        mkdir(parent, 0755);
    }
    mkdir(cache_dir, 0755);
#endif

    return true;
}

// Build full blob path in cache directory
static char *build_cache_path(const char *name) {
    char *cache_dir = get_cache_dir();
    if (!cache_dir) return NULL;

    size_t len = strlen(cache_dir) + strlen(name) + 10;
    char *path = malloc(len);
#ifdef _WIN32
    snprintf(path, len, "%s\\%s.bin", cache_dir, name);
#else
    snprintf(path, len, "%s/%s.bin", cache_dir, name);
#endif

    return path;
}

// Check if path looks like a simple name (no slashes)
static bool is_simple_name(const char *path) {
    while (*path) {
        if (*path == '/' || *path == '\\') return false;
        path++;
    }
    return true;
}

// Resolve blob path: if simple name, look in cache; otherwise use as-is
static char *resolve_blob_path(const char *blob_arg) {
    // If it contains path separators or ends with .bin, use as-is
    if (!is_simple_name(blob_arg)) {
        return strdup(blob_arg);
    }

    // Strip .bin extension if present
    char *name = strdup(blob_arg);
    size_t len = strlen(name);
    if (len > 4 && strcmp(name + len - 4, ".bin") == 0) {
        name[len - 4] = '\0';
    }

    char *path = build_cache_path(name);
    return path;
}

static void print_help(void) {
    puts("fast-completer - Universal fast completion provider\n");
    puts("Usage: fast-completer [--blob <path>] <format> <spans...>");
    puts("       fast-completer --generate-blob <schema> [output]\n");
    puts("Completion mode:");
    puts("  fast-completer <format> <spans...>\n");
    puts("  format        Output format (see below)");
    puts("  spans         Command line tokens starting with CLI name\n");
    puts("  --blob <path> Use blob at specified path instead of cache lookup\n");
    puts("  The CLI name is derived from the first span and used to look up");
    puts("  <name>.bin in the cache directory.\n");
    puts("  Cache location (override with FAST_COMPLETER_CACHE env var):");
#ifdef _WIN32
    puts("    %LOCALAPPDATA%\\fast-completer\\<name>.bin");
#else
    puts("    ~/.cache/fast-completer/<name>.bin");
#endif
    puts("");
    puts("Blob generation mode:");
    puts("  fast-completer --generate-blob [--big-endian] <schema> [output]\n");
    puts("  schema        Path to JSON or YAML schema file");
    puts("  output        Output path (optional - defaults to cache directory)");
    puts("  --big-endian  Generate big-endian blob\n");
    puts("  If output is omitted, reads 'name' from schema and saves to cache.\n");
    puts("Output formats:");
    puts("  bash, lines       One value per line (no descriptions)");
    puts("  zsh               value:description");
    puts("  fish, tsv         value\\tdescription");
    puts("  pwsh              PowerShell format");
    puts("  nushell, msgpack  MessagePack array of maps");
    puts("  json              JSON array of objects");
    puts("  json-tuple        JSON array of tuples");
    puts("  msgpack-tuple     MessagePack array of tuples\n");
    puts("Use 'lines' format when descriptions are not needed.\n");
    puts("Examples:");
    puts("  fast-completer --generate-blob aws.json");
    puts("      Generate blob from schema with {\"name\": \"aws\", ...}\n");
    puts("  fast-completer bash aws s3 \"\"");
    puts("      Complete subcommands after 'aws s3'\n");
    puts("  fast-completer --blob /path/to/custom.bin zsh mycli --");
    puts("      Complete flags using explicit blob path");
}

int main(int argc, char *argv[]) {
    if (argc >= 2 && (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0)) {
        print_help();
        return 0;
    }

    // Handle --generate-blob mode (must come first)
    if (argc >= 2 && strcmp(argv[1], "--generate-blob") == 0) {
        bool big_endian = false;
        int arg_idx = 2;

        if (argc > arg_idx && strcmp(argv[arg_idx], "--big-endian") == 0) {
            big_endian = true;
            arg_idx++;
        }

        if (argc < arg_idx + 1) {
            fprintf(stderr, "Usage: fast-completer --generate-blob [--big-endian] <schema> [output]\n");
            return 1;
        }

        const char *schema_path = argv[arg_idx];
        const char *output_path = (argc > arg_idx + 1) ? argv[arg_idx + 1] : NULL;
        char *derived_path = NULL;

        // If no output path, derive from schema's "name" property
        if (!output_path) {
            char *name = get_schema_name(schema_path);
            if (!name) {
                fprintf(stderr, "Schema must have 'name' property when output path is omitted\n");
                return 1;
            }
            ensure_cache_dir();
            derived_path = build_cache_path(name);
            output_path = derived_path;
        }

        bool result = generate_blob(schema_path, output_path, big_endian);
        return result ? 0 : 1;
    }

    // Parse completion mode arguments
    int arg_idx = 1;
    const char *explicit_blob_path = NULL;

    // Check for --blob option
    if (argc > arg_idx + 1 && strcmp(argv[arg_idx], "--blob") == 0) {
        explicit_blob_path = argv[arg_idx + 1];
        arg_idx += 2;
    }

    if (argc < arg_idx + 2) {
        fprintf(stderr, "Usage: fast-completer [--blob <path>] <format> <spans...>\n");
        fprintf(stderr, "Try 'fast-completer --help' for more information.\n");
        return 1;
    }

    const char *format_name = argv[arg_idx];
    int spans_start = arg_idx + 1;
    const char *cli_name = argv[spans_start]; // Derive from first span

    // Resolve blob path
    char *resolved_path = NULL;
    const char *blob_path;
    if (explicit_blob_path) {
        blob_path = explicit_blob_path;
    } else {
        resolved_path = resolve_blob_path(cli_name);
        blob_path = resolved_path;
    }

    output_format = parse_format(format_name);
    if (output_format == OUT_UNKNOWN) {
        fprintf(stderr, "Unknown output format: %s\n", format_name);
        fprintf(stderr, "Supported: lines, zsh, tsv, json, json-tuple, msgpack, msgpack-tuple, pwsh\n");
        return 1;
    }

    if (!load_blob(blob_path)) {
        // If cache lookup failed, show helpful error
        if (!explicit_blob_path && is_simple_name(cli_name)) {
            char *cache_dir = get_cache_dir();
            fprintf(stderr, "Blob '%s' not found in %s\n", cli_name, cache_dir ? cache_dir : "(unknown)");
            fprintf(stderr, "Generate it with: fast-completer --generate-blob <schema>\n");
        }
        return 1;
    }

    if (!alloc_buffers()) {
        return 1;
    }

    flockfile(stdout);
    complete(argc - spans_start, (const char **)(argv + spans_start));
    funlockfile(stdout);

    return 0;
}
