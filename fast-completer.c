/*
 * fast-completer - Universal fast completion provider for CLI tools
 *
 * Usage: fast-completer <blob> <output> <spans...>
 *
 * This program reads completion data from a binary blob file generated by
 * generate_blob.c, allowing a single completer binary to work with any CLI.
 *
 * The last span triggers completions:
 *   "" - subcommands + flags
 *   "-" or "--*" - flags only
 *   "abc..." - matching subcommands
 *
 * Output formats:
 *   lines, zsh, tsv, json, json-tuple, msgpack, msgpack-tuple, nushell, pwsh
 *   Aliases: bash -> lines, fish -> tsv, nu -> nushell
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "generate_blob.h"

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#else
#include <fcntl.h>
#include <poll.h>
#include <spawn.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>
#endif

// Supported output formats
typedef enum {
    OUT_LINES,
    OUT_ZSH,
    OUT_TSV,
    OUT_JSON,
    OUT_JSON_TUPLE,
    OUT_MSGPACK,
    OUT_MSGPACK_TUPLE,
    OUT_NUSHELL,
    OUT_PWSH,
    OUT_UNKNOWN
} OutputFormat;

// Completion types (for PowerShell)
typedef enum {
    COMP_COMMAND = 2,
    COMP_PARAM_NAME = 7,
    COMP_PARAM_VALUE = 8
} CompletionType;

// String with known length
typedef struct { const char *p; size_t n; } String;

// Create String from string literal
#define STR_LIT(s) ((String){s, sizeof(s) - 1})

// Packed structs matching binary format
#pragma pack(push, 1)
typedef struct {
    uint32_t name_off;
    uint32_t short_off;    // 0 if none, else offset into string table
    uint32_t desc_off;
    uint32_t choices_off;  // 0 if none, else absolute offset into blob
    uint8_t  flags;        // FLAG_TAKES_VALUE, FLAG_IS_MEMBERS
} Param;

typedef struct {
    uint32_t name_off;
    uint32_t desc_off;
    uint32_t params_idx;
    uint16_t subcommands_idx;
    uint16_t params_count;
    uint16_t subcommands_count;
} Command;
#pragma pack(pop)

// Blob header (parsed at load time - only fields actually used)
typedef struct {
    uint32_t max_command_path_len;
    uint32_t msgpack_buffer_size;
    uint32_t global_params_count;
    uint32_t string_table_off;
    uint32_t commands_off;
    uint32_t params_off;
    uint32_t global_params_off;
    uint32_t root_command_off;
} BlobHeader;

// Global state
static const uint8_t *blob = NULL;
static BlobHeader header;
static OutputFormat output_format;
static bool has_descriptions = true;  // Set from blob flags
static bool add_trailing_space = false;  // Add trailing space to completion values

// Working buffers (allocated based on header values)
static uint8_t *msgpack_buf = NULL;
static size_t msgpack_len = 0;
static uint32_t msgpack_count = 0;
static char *path_buf = NULL;

// Completion context (set once per complete() call)
static const char **g_spans = NULL;
static size_t *g_arg_lens = NULL;
static int g_span_count = 0;

// Accessor macros
#define PARAM_TAKES_VALUE(p)   ((p)->flags & FLAG_TAKES_VALUE)
#define PARAM_IS_MEMBERS(p)    ((p)->flags & FLAG_IS_MEMBERS)
#define PARAM_IS_COMPLETER(p)  ((p)->flags & FLAG_IS_COMPLETER)
#define PARAM_HAS_CHOICES(p)   ((p)->choices_off && !((p)->flags & (FLAG_IS_MEMBERS | FLAG_IS_COMPLETER)))
#define PARAM_HAS_MEMBERS(p)   ((p)->choices_off && ((p)->flags & FLAG_IS_MEMBERS))
#define PARAM_HAS_COMPLETER(p) ((p)->choices_off && ((p)->flags & FLAG_IS_COMPLETER))

// Get string from string table
static inline String str_get(uint32_t off) {
    String s;
    if (off == 0) {
        s.p = "";
        s.n = 0;
        return s;
    }
    const uint8_t *p = blob + header.string_table_off + off;
    if (p[0] < 128) {
        s.n = p[0];
        s.p = (const char *)(p + 1);
    } else {
        s.n = ((p[0] & 0x7f) << 8) | p[1];
        s.p = (const char *)(p + 2);
    }
    return s;
}

// Compare string table entry with C string (pre-computed length)
static inline bool str_eq_n(uint32_t off, const char *cstr, size_t clen) {
    String s = str_get(off);
    return s.n == clen && memcmp(s.p, cstr, clen) == 0;
}

// Get command by index
static inline const Command *get_command(uint32_t idx) {
    return (const Command *)(blob + header.commands_off + idx * COMMAND_SIZE);
}

// Get param by index
static inline const Param *get_param(uint32_t idx) {
    return (const Param *)(blob + header.params_off + idx * PARAM_SIZE);
}

// Get root command
static inline const Command *get_root_command(void) {
    return (const Command *)(blob + header.root_command_off);
}

// Get global params array
static inline const Param *get_global_params(void) {
    return (const Param *)(blob + header.global_params_off);
}

// Get command's params (NULL if none)
static inline const Param *cmd_params(const Command *cmd) {
    return cmd->params_count ? get_param(cmd->params_idx) : NULL;
}

// Get command's subcommands (NULL if none)
static inline const Command *cmd_subcommands(const Command *cmd) {
    return cmd->subcommands_count ? get_command(cmd->subcommands_idx) : NULL;
}

// Read variable-length count-prefixed array of string offsets
// Format: u8 count if <255, else 0xFF + u16 count, then count * u32 offsets
static inline uint16_t get_string_list_count(uint32_t off) {
    uint8_t first = blob[off];
    if (first < 255) return first;
    return *(const uint16_t *)(blob + off + 1);
}

static inline const uint32_t *get_string_offsets(uint32_t off) {
    uint8_t first = blob[off];
    return (const uint32_t *)(blob + off + (first < 255 ? 1 : 3));
}

// Track if we've started the JSON array
static bool json_started = false;

// MessagePack helpers
static void msgpack_write_byte(uint8_t b) {
    msgpack_buf[msgpack_len++] = b;
}

static void msgpack_write_bytes(const void *data, size_t len) {
    memcpy(msgpack_buf + msgpack_len, data, len);
    msgpack_len += len;
}

static void msgpack_write_str_header(size_t len) {
    if (len <= 31) {
        msgpack_write_byte(0xa0 | (uint8_t)len);
    } else if (len <= 255) {
        msgpack_write_byte(0xd9);
        msgpack_write_byte((uint8_t)len);
    } else if (len <= 65535) {
        msgpack_write_byte(0xda);
        uint8_t buf[2] = { (uint8_t)(len >> 8), (uint8_t)len };
        msgpack_write_bytes(buf, 2);
    } else {
        msgpack_write_byte(0xdb);
        uint8_t buf[4] = { (uint8_t)(len >> 24), (uint8_t)(len >> 16),
                          (uint8_t)(len >> 8), (uint8_t)len };
        msgpack_write_bytes(buf, 4);
    }
}

static void msgpack_write_str(String s) {
    msgpack_write_str_header(s.n);
    msgpack_write_bytes(s.p, s.n);
}

static inline bool needs_trailing_space(String s) {
    return s.n > 0 && s.p[s.n - 1] != '=';
}

static void msgpack_write_str_with_space(String s) {
    msgpack_write_str_header(s.n + 1);
    msgpack_write_bytes(s.p, s.n);
    msgpack_write_byte(' ');
}

// I/O helpers
#ifdef _WIN32
static inline void put_char(int c) {
    _putc_nolock(c, stdout);
}
static inline void put_bytes(const char *p, size_t n) {
    _fwrite_nolock(p, 1, n, stdout);
}
#define flockfile(f) _lock_file(f)
#define funlockfile(f) _unlock_file(f)
#else
static inline void put_char(int c) {
    putc_unlocked(c, stdout);
}
#ifdef __APPLE__
#define put_bytes(p, n) fwrite(p, 1, n, stdout)
#else
static inline void put_bytes(const char *p, size_t n) {
    fwrite_unlocked(p, 1, n, stdout);
}
#endif
#endif

#define put_lit(s) put_bytes(s, sizeof(s) - 1)

static inline void put_str(String s) {
    put_bytes(s.p, s.n);
}

// JSON string escaping
static void print_json_str(String s) {
    static const char hex[] = "0123456789abcdef";
    put_char('"');
    for (size_t i = 0; i < s.n; i++) {
        switch (s.p[i]) {
            case '"':  put_lit("\\\""); break;
            case '\\': put_lit("\\\\"); break;
            case '\n': put_lit("\\n"); break;
            case '\r': put_lit("\\r"); break;
            case '\t': put_lit("\\t"); break;
            default:
                if ((unsigned char)s.p[i] < 32) {
                    put_lit("\\u00");
                    put_char(hex[(unsigned char)s.p[i] >> 4]);
                    put_char(hex[(unsigned char)s.p[i] & 0xf]);
                } else {
                    put_char(s.p[i]);
                }
        }
    }
    put_char('"');
}

// Output a completion item
static void output_completion(String value, String desc, CompletionType type) {
    switch (output_format) {
    case OUT_JSON:
        if (json_started) put_char(',');
        json_started = true;
        put_char('{');
        print_json_str(STR_LIT("value"));
        put_char(':');
        print_json_str(value);
        if (desc.n > 0) {
            put_char(',');
            print_json_str(STR_LIT("description"));
            put_char(':');
            print_json_str(desc);
        }
        put_char('}');
        break;

    case OUT_TSV:
        put_str(value);
        if (desc.n > 0) {
            put_char('\t');
            put_str(desc);
        }
        put_char('\n');
        break;

    case OUT_ZSH:
        put_str(value);
        if (desc.n > 0) {
            put_char(':');
            for (size_t i = 0; i < desc.n; i++) {
                if (desc.p[i] == '\\') put_char('\\');  // escape backslashes
                put_char(desc.p[i]);
            }
        }
        put_char('\n');
        break;

    case OUT_LINES:
        put_str(value);
        put_char('\n');
        break;

    case OUT_PWSH:
        put_str(value);
        put_char('\t');
        put_str(value);
        put_char('\t');
        put_char('0' + type);
        put_char('\t');
        put_str(desc.n > 0 ? desc : value);
        put_char('\n');
        break;

    case OUT_JSON_TUPLE:
        if (json_started) put_char(',');
        json_started = true;
        put_char('[');
        print_json_str(value);
        put_char(',');
        print_json_str(desc);
        put_char(']');
        break;

    case OUT_NUSHELL:
    case OUT_MSGPACK:
        msgpack_write_byte(desc.n > 0 ? 0x82 : 0x81);
        msgpack_write_str(STR_LIT("value"));
        if (add_trailing_space && needs_trailing_space(value))
            msgpack_write_str_with_space(value);
        else
            msgpack_write_str(value);
        if (desc.n > 0) {
            msgpack_write_str(STR_LIT("description"));
            msgpack_write_str(desc);
        }
        msgpack_count++;
        break;

    case OUT_MSGPACK_TUPLE:
        msgpack_write_byte(0x92);
        msgpack_write_str(value);
        msgpack_write_str(desc);
        msgpack_count++;
        break;

    default:
        put_str(value);
        put_char('\n');
        break;
    }
}

// Compare strings lexicographically (for binary search)
static inline int str_cmp(const char *a, size_t a_len, const char *b, size_t b_len) {
    size_t min_len = (a_len < b_len) ? a_len : b_len;
    int cmp = memcmp(a, b, min_len);
    if (cmp != 0) return cmp;
    return (a_len < b_len) ? -1 : (a_len > b_len) ? 1 : 0;
}

// Binary search for a command by name among sorted subcommands
static const Command *bsearch_command(const Command *subs, uint16_t count, const char *name, size_t name_len) {
    uint16_t lo = 0, hi = count;
    while (lo < hi) {
        uint16_t mid = lo + (hi - lo) / 2;
        String s = str_get(subs[mid].name_off);
        int cmp = str_cmp(s.p, s.n, name, name_len);
        if (cmp < 0) lo = mid + 1;
        else if (cmp > 0) hi = mid;
        else return &subs[mid];
    }
    return NULL;
}

// Find the deepest matching command
static const Command *find_command(void) {
    const Command *cmd = get_root_command();
    int i = 1;  // Skip first arg (CLI name)

    while (i < g_span_count && cmd->subcommands_count > 0) {
        const char *arg = g_spans[i];

        if (arg[0] == '-') {
            i++;
            continue;
        }

        size_t arg_len = g_arg_lens[i];
        const Command *found = bsearch_command(cmd_subcommands(cmd), cmd->subcommands_count, arg, arg_len);

        if (found) {
            cmd = found;
            i++;
        } else {
            break;
        }
    }

    return cmd;
}

// Check if a parameter has already been used (by long or short name)
static bool param_used(const Param *param) {
    String name = str_get(param->name_off);
    String short_opt = param->short_off ? str_get(param->short_off) : (String){NULL, 0};

    for (int i = 0; i < g_span_count; i++) {
        size_t arg_len = g_arg_lens[i];
        if (arg_len == name.n && memcmp(g_spans[i], name.p, name.n) == 0)
            return true;
        if (short_opt.p && arg_len == short_opt.n && memcmp(g_spans[i], short_opt.p, short_opt.n) == 0)
            return true;
    }
    return false;
}

// Pre-computed prefix analysis for parameter completion
typedef struct {
    size_t len;
    bool is_dash;         // starts with -
    bool is_double_dash;  // starts with --
    bool is_single_dash;  // starts with - but not --
} PrefixInfo;

static inline PrefixInfo make_prefix_info(const char *prefix, size_t len) {
    PrefixInfo info = {0};
    if (prefix && len > 0) {
        info.len = len;
        info.is_dash = prefix[0] == '-';
        info.is_double_dash = len >= 2 && prefix[0] == '-' && prefix[1] == '-';
        info.is_single_dash = info.is_dash && !info.is_double_dash;
    }
    return info;
}

// Recursively output leaf commands
static void complete_leaf_commands(const Command *cmd, String path, const char *prefix, size_t prefix_len) {
    if (cmd->subcommands_count == 0) return;

    char *buf = path_buf;
    const Command *subs = cmd_subcommands(cmd);

    for (uint16_t i = 0; i < cmd->subcommands_count; i++) {
        const Command *sub = &subs[i];
        String sub_name = str_get(sub->name_off);

        size_t new_len;
        if (path.n > 0) {
            if (path.n + 1 + sub_name.n >= header.max_command_path_len) continue;
            buf[path.n] = ' ';
            memcpy(buf + path.n + 1, sub_name.p, sub_name.n);
            new_len = path.n + 1 + sub_name.n;
        } else {
            if (sub_name.n >= header.max_command_path_len) continue;
            memcpy(buf, sub_name.p, sub_name.n);
            new_len = sub_name.n;
        }
        buf[new_len] = '\0';

        bool matches = !prefix || strncmp(buf, prefix, prefix_len) == 0;

        if (sub->subcommands_count > 0) {
            if (!prefix || matches || strncmp(prefix, buf, new_len) == 0) {
                complete_leaf_commands(sub, (String){buf, new_len}, prefix, prefix_len);
            }
        } else if (matches) {
            uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : sub->desc_off;
            output_completion((String){buf, new_len}, str_get(desc), COMP_COMMAND);
        }

        buf[path.n] = '\0';
    }
}

// Complete subcommands (leaf commands only)
static void complete_subcommands(const Command *cmd, const char *prefix, size_t prefix_len) {
    path_buf[0] = '\0';
    complete_leaf_commands(cmd, (String){path_buf, 0}, prefix, prefix_len);
}

// Complete parameters from a param list
static void complete_params_list(const Param *params, uint16_t params_count,
                                  const char *prefix, const PrefixInfo *pinfo) {
    if (!params || params_count == 0) return;
    if (pinfo->len > 0 && !pinfo->is_dash) return;

    // When prefix is "-" (single dash only), show short options first
    if (pinfo->is_single_dash) {
        for (uint16_t i = 0; i < params_count; i++) {
            const Param *p = &params[i];
            if (p->short_off == 0) continue;
            if (param_used(p)) continue;

            String short_opt = str_get(p->short_off);
            if (short_opt.n >= pinfo->len && memcmp(short_opt.p, prefix, pinfo->len) == 0) {
                uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : p->desc_off;
                output_completion(short_opt, str_get(desc), COMP_PARAM_NAME);
            }
        }
    }

    // Show long options (always, unless prefix is single dash with more chars like "-x")
    if (!pinfo->is_single_dash || pinfo->len == 1) {
        for (uint16_t i = 0; i < params_count; i++) {
            const Param *p = &params[i];
            if (param_used(p)) continue;

            String name = str_get(p->name_off);
            if (pinfo->len == 0 || (name.n >= pinfo->len && memcmp(name.p, prefix, pinfo->len) == 0)) {
                uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : p->desc_off;
                output_completion(name, str_get(desc), COMP_PARAM_NAME);
            }
        }
    }
}

// Complete global params
static void complete_global_params(const char *prefix, const PrefixInfo *pinfo) {
    if (header.global_params_count == 0) return;
    if (pinfo->len > 0 && !pinfo->is_dash) return;

    const Param *global_params = get_global_params();

    // When prefix is "-" (single dash only), show short options first
    if (pinfo->is_single_dash) {
        for (uint32_t i = 0; i < header.global_params_count; i++) {
            const Param *p = &global_params[i];
            if (p->short_off == 0) continue;
            if (param_used(p)) continue;

            String short_opt = str_get(p->short_off);
            if (short_opt.n >= pinfo->len && memcmp(short_opt.p, prefix, pinfo->len) == 0) {
                uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : p->desc_off;
                output_completion(short_opt, str_get(desc), COMP_PARAM_NAME);
            }
        }
    }

    // Show long options
    if (!pinfo->is_single_dash || pinfo->len == 1) {
        for (uint32_t i = 0; i < header.global_params_count; i++) {
            const Param *p = &global_params[i];
            if (param_used(p)) continue;

            String name = str_get(p->name_off);
            if (pinfo->len == 0 || (name.n >= pinfo->len && memcmp(name.p, prefix, pinfo->len) == 0)) {
                uint32_t desc = !has_descriptions || output_format == OUT_LINES ? 0 : p->desc_off;
                output_completion(name, str_get(desc), COMP_PARAM_NAME);
            }
        }
    }
}

// Complete string list at a blob offset (choices or members)
static void complete_string_list(uint32_t off, const char *prefix, size_t prefix_len) {
    if (off == 0) return;

    uint16_t count = get_string_list_count(off);
    const uint32_t *offsets = get_string_offsets(off);

    for (uint16_t i = 0; i < count; i++) {
        String s = str_get(offsets[i]);
        if (!prefix || (s.n >= prefix_len && memcmp(s.p, prefix, prefix_len) == 0)) {
            output_completion(s, str_get(0), COMP_PARAM_VALUE);
        }
    }
}

// Split command string into argv array (simple space splitting)
// Returns argc, fills argv (must have room for max_args+1 entries, last is NULL)
static int split_args(char *cmd, char **argv, int max_args) {
    int argc = 0;
    char *p = cmd;
    while (*p && argc < max_args) {
        while (*p == ' ') p++;  // Skip spaces
        if (!*p) break;
        argv[argc++] = p;
        while (*p && *p != ' ') p++;  // Find end of arg
        if (*p) *p++ = '\0';  // Null-terminate
    }
    argv[argc] = NULL;
    return argc;
}

// Execute a dynamic completer command and output results
// cli_name: CLI name (e.g., "az") from g_spans[0]
// completer: subcommand args (e.g., "aks get-versions --output tsv") - String with length
// prefix: optional prefix to filter results
// prefix_len: length of prefix
static void execute_completer(const char *cli_name, String completer,
                               const char *prefix, size_t prefix_len) {
    if (!cli_name || !completer.p || completer.n == 0) return;

    // Build argument string: copy completer (need mutable string for splitting)
    char *args = malloc(completer.n + 1);
    if (!args) return;
    memcpy(args, completer.p, completer.n);
    args[completer.n] = '\0';

    // Split into argv: [cli_name, arg1, arg2, ..., NULL]
    char *argv[64];
    argv[0] = (char *)cli_name;
    split_args(args, argv + 1, 62);

#ifdef _WIN32
    // Windows implementation using overlapped I/O with direct exec (no cmd.exe shell)
    // Note: No cleanup needed - process exits after completion, OS reclaims all resources

    // Build command line string from argv for CreateProcess
    // Format: "cli arg1 arg2 ..." (CreateProcess expects space-separated)
    size_t cmdline_len = strlen(cli_name) + 1 + completer.n + 1;
    char *cmdline = malloc(cmdline_len);
    if (!cmdline) return;
    snprintf(cmdline, cmdline_len, "%s %.*s", cli_name, (int)completer.n, completer.p);

    // Create named pipe with FILE_FLAG_OVERLAPPED for async reads
    char pipe_name[256];
    snprintf(pipe_name, sizeof(pipe_name), "\\\\.\\pipe\\fc_%lu_%lu",
             (unsigned long)GetCurrentProcessId(), (unsigned long)GetTickCount());

    HANDLE stdout_read = CreateNamedPipeA(
        pipe_name, PIPE_ACCESS_INBOUND | FILE_FLAG_OVERLAPPED,
        PIPE_TYPE_BYTE | PIPE_WAIT, 1, 4096, 4096, 0, NULL);
    if (stdout_read == INVALID_HANDLE_VALUE) return;

    SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
    HANDLE stdout_write = CreateFileA(pipe_name, GENERIC_WRITE, 0, &sa, OPEN_EXISTING, 0, NULL);
    if (stdout_write == INVALID_HANDLE_VALUE) return;

    STARTUPINFOA si = { sizeof(STARTUPINFOA) };
    si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
    si.hStdOutput = stdout_write;
    si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
    si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
    si.wShowWindow = SW_HIDE;

    PROCESS_INFORMATION pi = {0};
    if (!CreateProcessA(NULL, cmdline, NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) return;
    CloseHandle(stdout_write);  // Child has it, close so reads see EOF when child exits

    // Overlapped read setup
    OVERLAPPED ov = {0};
    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!ov.hEvent) { TerminateProcess(pi.hProcess, 1); return; }

    char line[4096];
    size_t line_pos = 0;
    char buf[4096];
    DWORD bytes_read;
    ULONGLONG start_time = GetTickCount64();
    HANDLE wait_handles[2] = {ov.hEvent, pi.hProcess};

    while (1) {
        ULONGLONG elapsed = GetTickCount64() - start_time;
        DWORD remaining = (elapsed >= 2000) ? 0 : (2000 - elapsed);

        ResetEvent(ov.hEvent);
        BOOL read_ok = ReadFile(stdout_read, buf, sizeof(buf), &bytes_read, &ov);
        DWORD err = GetLastError();

        if (!read_ok && err == ERROR_IO_PENDING) {
            DWORD wait = WaitForMultipleObjects(2, wait_handles, FALSE, remaining);
            if (wait == WAIT_OBJECT_0) {
                if (!GetOverlappedResult(stdout_read, &ov, &bytes_read, FALSE)) break;
            } else if (wait == WAIT_OBJECT_0 + 1) {
                CancelIo(stdout_read);
                if (!GetOverlappedResult(stdout_read, &ov, &bytes_read, FALSE) || bytes_read == 0) break;
            } else {
                CancelIo(stdout_read);
                TerminateProcess(pi.hProcess, 1);
                break;
            }
        } else if (!read_ok) {
            break;
        }

        for (DWORD i = 0; i < bytes_read; i++) {
            if (buf[i] == '\n' || buf[i] == '\r') {
                if (line_pos > 0) {
                    line[line_pos] = '\0';
                    if (!prefix || (line_pos >= prefix_len && memcmp(line, prefix, prefix_len) == 0))
                        output_completion((String){line, line_pos}, str_get(0), COMP_PARAM_VALUE);
                    line_pos = 0;
                }
            } else if (line_pos < sizeof(line) - 1) {
                line[line_pos++] = buf[i];
            }
        }
    }

    if (line_pos > 0) {
        line[line_pos] = '\0';
        if (!prefix || (line_pos >= prefix_len && memcmp(line, prefix, prefix_len) == 0))
            output_completion((String){line, line_pos}, str_get(0), COMP_PARAM_VALUE);
    }
#else
    // Unix implementation using posix_spawnp with direct exec (no shell)
    int pipefd[2];
    if (pipe(pipefd) < 0) return;

    posix_spawn_file_actions_t actions;
    posix_spawn_file_actions_init(&actions);
    posix_spawn_file_actions_addclose(&actions, pipefd[0]);
    posix_spawn_file_actions_adddup2(&actions, pipefd[1], STDOUT_FILENO);
    posix_spawn_file_actions_addclose(&actions, pipefd[1]);
    posix_spawn_file_actions_addopen(&actions, STDERR_FILENO, "/dev/null", O_WRONLY, 0);

    extern char **environ;
    pid_t pid;
    if (posix_spawnp(&pid, cli_name, &actions, NULL, argv, environ) != 0) return;
    close(pipefd[1]);  // Close write end so reads see EOF when child exits

    // Non-blocking reads with poll() timeout
    fcntl(pipefd[0], F_SETFL, fcntl(pipefd[0], F_GETFL) | O_NONBLOCK);

    char line[4096];
    size_t line_pos = 0;
    char buf[4096];
    struct timespec start, now;
    clock_gettime(CLOCK_MONOTONIC, &start);
    int timeout_ms = 2000;

    while (timeout_ms > 0) {
        struct pollfd pfd = { .fd = pipefd[0], .events = POLLIN };
        if (poll(&pfd, 1, timeout_ms) <= 0) break;

        ssize_t n = read(pipefd[0], buf, sizeof(buf));
        if (n <= 0) break;

        for (ssize_t i = 0; i < n; i++) {
            if (buf[i] == '\n') {
                if (line_pos > 0) {
                    line[line_pos] = '\0';
                    if (!prefix || (line_pos >= prefix_len && memcmp(line, prefix, prefix_len) == 0))
                        output_completion((String){line, line_pos}, str_get(0), COMP_PARAM_VALUE);
                    line_pos = 0;
                }
            } else if (line_pos < sizeof(line) - 1) {
                line[line_pos++] = buf[i];
            }
        }

        // Update remaining timeout
        clock_gettime(CLOCK_MONOTONIC, &now);
        int elapsed_ms = (now.tv_sec - start.tv_sec) * 1000 + (now.tv_nsec - start.tv_nsec) / 1000000;
        timeout_ms = 2000 - elapsed_ms;
    }

    if (line_pos > 0) {
        line[line_pos] = '\0';
        if (!prefix || (line_pos >= prefix_len && memcmp(line, prefix, prefix_len) == 0))
            output_completion((String){line, line_pos}, str_get(0), COMP_PARAM_VALUE);
    }

    if (waitpid(pid, NULL, WNOHANG) == 0) {
        kill(pid, SIGKILL);
        waitpid(pid, NULL, 0);  // Reap zombie
    }
#endif
}

// Binary search for a param by long name among sorted params
static const Param *bsearch_param(const Param *params, uint16_t count, const char *name, size_t name_len) {
    uint16_t lo = 0, hi = count;
    while (lo < hi) {
        uint16_t mid = lo + (hi - lo) / 2;
        String s = str_get(params[mid].name_off);
        int cmp = str_cmp(s.p, s.n, name, name_len);
        if (cmp < 0) lo = mid + 1;
        else if (cmp > 0) hi = mid;
        else return &params[mid];
    }
    return NULL;
}

// Find a parameter by name (long or short option)
static const Param *find_param(const Param *params, uint16_t params_count, const char *opt, size_t opt_len) {
    if (!params || params_count == 0 || !opt) return NULL;
    if (opt[0] != '-') return NULL;

    // Binary search for long option (--name)
    const Param *p = bsearch_param(params, params_count, opt, opt_len);
    if (p) return p;

    // Linear fallback for short options (-x) - rare in practice
    if (opt_len == 2 && opt[0] == '-' && opt[1] != '-') {
        for (uint16_t i = 0; i < params_count; i++) {
            if (params[i].short_off) {
                String short_opt = str_get(params[i].short_off);
                if (short_opt.n == opt_len && memcmp(short_opt.p, opt, opt_len) == 0)
                    return &params[i];
            }
        }
    }
    return NULL;
}

// Find a global param by name (long or short option)
static const Param *find_global_param(const char *name, size_t len) {
    if (header.global_params_count == 0) return NULL;

    const Param *global_params = get_global_params();
    for (uint32_t i = 0; i < header.global_params_count; i++) {
        const Param *p = &global_params[i];
        // Check long option
        String pname = str_get(p->name_off);
        if (pname.n == len && memcmp(pname.p, name, len) == 0)
            return p;
        // Check short option
        if (p->short_off) {
            String short_opt = str_get(p->short_off);
            if (short_opt.n == len && memcmp(short_opt.p, name, len) == 0)
                return p;
        }
    }
    return NULL;
}

// Check if span is empty/whitespace
static inline bool is_new_arg(const char *span) {
    if (!span || !*span) return true;
    // Fast path: if first char is not whitespace, it's not a new arg
    if (span[0] != ' ' && span[0] != '\t') return false;
    // Slow path: check remaining chars for non-whitespace
    for (const char *p = span + 1; *p; p++) {
        if (*p != ' ' && *p != '\t') return false;
    }
    return true;
}

// Parse output format - uses first char + length for fast dispatch
static OutputFormat parse_format(const char *name) {
    size_t len = strlen(name);
    // Quick dispatch on first char and length
    switch (name[0]) {
    case 'b':
        if (len == 4 && memcmp(name, "bash", 4) == 0) return OUT_LINES;
        break;
    case 'f':
        if (len == 4 && memcmp(name, "fish", 4) == 0) return OUT_TSV;
        break;
    case 'j':
        if (len == 4 && memcmp(name, "json", 4) == 0) return OUT_JSON;
        if (len == 10 && memcmp(name, "json-tuple", 10) == 0) return OUT_JSON_TUPLE;
        break;
    case 'l':
        if (len == 5 && memcmp(name, "lines", 5) == 0) return OUT_LINES;
        break;
    case 'm':
        if (len == 7 && memcmp(name, "msgpack", 7) == 0) return OUT_MSGPACK;
        if (len == 13 && memcmp(name, "msgpack-tuple", 13) == 0) return OUT_MSGPACK_TUPLE;
        break;
    case 'n':
        if (len == 2 && name[1] == 'u') return OUT_NUSHELL;
        if (len == 7 && memcmp(name, "nushell", 7) == 0) return OUT_NUSHELL;
        break;
    case 'p':
        if (len == 4 && memcmp(name, "pwsh", 4) == 0) return OUT_PWSH;
        if (len == 10 && memcmp(name, "powershell", 10) == 0) return OUT_PWSH;
        break;
    case 't':
        if (len == 3 && memcmp(name, "tsv", 3) == 0) return OUT_TSV;
        break;
    case 'z':
        if (len == 3 && memcmp(name, "zsh", 3) == 0) return OUT_ZSH;
        break;
    }
    return OUT_UNKNOWN;
}

// Output format header
static void output_header(void) {
    if (output_format == OUT_JSON || output_format == OUT_JSON_TUPLE) {
        put_char('[');
    }
}

// Output format footer
static void output_footer(void) {
    if (output_format == OUT_JSON || output_format == OUT_JSON_TUPLE) {
        put_lit("]\n");
    } else if (output_format == OUT_MSGPACK || output_format == OUT_MSGPACK_TUPLE || output_format == OUT_NUSHELL) {
        uint8_t hdr[5];
        size_t hdr_len;
        if (msgpack_count <= 15) {
            hdr[0] = 0x90 | (uint8_t)msgpack_count;
            hdr_len = 1;
        } else if (msgpack_count <= 65535) {
            hdr[0] = 0xdc;
            hdr[1] = (uint8_t)(msgpack_count >> 8);
            hdr[2] = (uint8_t)msgpack_count;
            hdr_len = 3;
        } else {
            hdr[0] = 0xdd;
            hdr[1] = (uint8_t)(msgpack_count >> 24);
            hdr[2] = (uint8_t)(msgpack_count >> 16);
            hdr[3] = (uint8_t)(msgpack_count >> 8);
            hdr[4] = (uint8_t)msgpack_count;
            hdr_len = 5;
        }
        put_bytes((const char *)hdr, hdr_len);
        if (msgpack_len > 0) {
            put_bytes((const char *)msgpack_buf, msgpack_len);
        }
    }
}

// Main completion logic
static void complete(int nspans, const char **spans) {
    output_header();

    if (nspans == 0) {
        output_footer();
        return;
    }

    // Pre-compute all arg lengths once and set globals
    size_t arg_lens[nspans];
    for (int i = 0; i < nspans; i++) {
        arg_lens[i] = strlen(spans[i]);
    }
    g_spans = spans;
    g_arg_lens = arg_lens;
    g_span_count = nspans - 1;
    if (g_span_count < 1) g_span_count = 1;

    const char *last_span = spans[nspans - 1];
    size_t last_span_len = arg_lens[nspans - 1];
    bool is_empty = is_new_arg(last_span);
    bool is_flag_prefix = last_span[0] == '-';
    bool is_cmd_prefix = last_span[0] >= 'a' && last_span[0] <= 'z';

    const Command *cmd = find_command();

    if (is_flag_prefix) {
        PrefixInfo pinfo = make_prefix_info(last_span, last_span_len);
        complete_params_list(cmd_params(cmd), cmd->params_count, last_span, &pinfo);
        complete_global_params(last_span, &pinfo);
        output_footer();
        return;
    }

    if (is_cmd_prefix) {
        if (cmd->subcommands_count > 0) {
            complete_subcommands(cmd, last_span, last_span_len);
        }
        output_footer();
        return;
    }

    if (!is_empty) {
        output_footer();
        return;
    }

    const char *prev_arg = g_span_count > 0 ? spans[g_span_count - 1] : "";

    if (prev_arg[0] == '-') {
        size_t prev_len = arg_lens[g_span_count - 1];

        const Param *gparam = find_global_param(prev_arg, prev_len);
        if (gparam && PARAM_TAKES_VALUE(gparam)) {
            if (PARAM_HAS_CHOICES(gparam)) {
                complete_string_list(gparam->choices_off, NULL, 0);
            } else if (PARAM_HAS_COMPLETER(gparam)) {
                execute_completer(g_spans[0], str_get(gparam->choices_off), NULL, 0);
            }
            output_footer();
            return;
        }

        const Param *param = find_param(cmd_params(cmd), cmd->params_count, prev_arg, prev_len);
        if (param && PARAM_TAKES_VALUE(param)) {
            if (PARAM_HAS_CHOICES(param)) {
                complete_string_list(param->choices_off, NULL, 0);
            } else if (PARAM_HAS_MEMBERS(param)) {
                complete_string_list(param->choices_off, NULL, 0);
            } else if (PARAM_HAS_COMPLETER(param)) {
                // Execute dynamic completer command
                execute_completer(g_spans[0], str_get(param->choices_off), NULL, 0);
            }
            output_footer();
            return;
        }
    }

    if (cmd->subcommands_count > 0) {
        complete_subcommands(cmd, NULL, 0);
    }

    PrefixInfo pinfo = {0};  // Empty prefix
    complete_params_list(cmd_params(cmd), cmd->params_count, NULL, &pinfo);
    complete_global_params(NULL, &pinfo);

    output_footer();
}

// Load and validate blob file
static bool load_blob(const char *path) {
#ifdef _WIN32
    HANDLE fh = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fh == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "%s: %lu\n", path, GetLastError());
        return false;
    }

    LARGE_INTEGER size;
    if (!GetFileSizeEx(fh, &size)) {
        fprintf(stderr, "GetFileSizeEx: %lu\n", GetLastError());
        return false;
    }
    size_t blob_size = (size_t)size.QuadPart;

    if (blob_size < HEADER_SIZE) {
        fprintf(stderr, "%s: file too small\n", path);
        return false;
    }

    HANDLE mapping = CreateFileMappingA(fh, NULL, PAGE_READONLY, 0, 0, NULL);
    if (!mapping) {
        fprintf(stderr, "CreateFileMapping: %lu\n", GetLastError());
        return false;
    }

    blob = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
    if (!blob) {
        fprintf(stderr, "MapViewOfFile: %lu\n", GetLastError());
        CloseHandle(mapping);
        CloseHandle(fh);
        return false;
    }
    CloseHandle(mapping);  // Mapping remains valid until UnmapViewOfFile
    CloseHandle(fh);       // File handle no longer needed
#else
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        perror(path);
        return false;
    }

    struct stat st;
    if (fstat(fd, &st) < 0) {
        perror("fstat");
        return false;
    }

    size_t blob_size = st.st_size;
    if (blob_size < HEADER_SIZE) {
        fprintf(stderr, "%s: file too small\n", path);
        return false;
    }

    blob = mmap(NULL, blob_size, PROT_READ, MAP_PRIVATE, fd, 0);
    close(fd);  // fd no longer needed after mmap
    if (blob == MAP_FAILED) {
        perror("mmap");
        blob = NULL;
        return false;
    }
#endif

    // Validate magic
    if (memcmp(blob, BLOB_MAGIC, 4) != 0) {
        fprintf(stderr, "%s: invalid magic\n", path);
        return false;
    }

    // Check endianness compatibility BEFORE reading other fields
    // Big-endian blobs store flags as [0x00, 0x01] at offset 6-7
    // Little-endian blobs store flags as [0x00, 0x00] at offset 6-7
    bool blob_is_big_endian = (blob[6] == 0x00 && blob[7] == 0x01);
    bool system_is_big_endian = (*(uint16_t *)"\0\1" == 1);
    if (blob_is_big_endian != system_is_big_endian) {
        fprintf(stderr, "%s: endianness mismatch (blob is %s-endian, system is %s-endian)\n",
                path,
                blob_is_big_endian ? "big" : "little",
                system_is_big_endian ? "big" : "little");
        return false;
    }

    // Validate version (now safe to read as native endianness)
    uint16_t version = *(uint16_t *)(blob + 4);
    if (version != BLOB_VERSION) {
        fprintf(stderr, "%s: unsupported version %d (expected %d)\n", path, version, BLOB_VERSION);
        return false;
    }

    // Check if blob has descriptions
    uint16_t flags = *(uint16_t *)(blob + 6);
    has_descriptions = !(flags & HEADER_FLAG_NO_DESCRIPTIONS);

    // Parse header (skip magic:4, version:2, flags:2 = offset 8)
    const uint32_t *h = (const uint32_t *)(blob + 8);
    header.max_command_path_len = h[0];
    header.msgpack_buffer_size = h[1];
    // h[2]-h[3] are commands_count, params_count (unused - counts in Command struct)
    header.global_params_count = h[4];
    // h[5]-h[7] are strtab size, choices_count, members_count (unused)
    header.string_table_off = h[8];
    header.commands_off = h[9];
    header.params_off = h[10];
    // h[11]-h[12] are choices_off, members_off (accessed via Param.choices_off)
    header.global_params_off = h[13];
    header.root_command_off = h[14];

    return true;
}

// Allocate working buffers based on output format
static bool alloc_buffers(void) {
    // Always need path buffer for subcommand completion
    path_buf = malloc(header.max_command_path_len);
    if (!path_buf) {
        perror("malloc");
        return false;
    }

    // Only allocate msgpack buffer if needed
    if (output_format == OUT_MSGPACK || output_format == OUT_MSGPACK_TUPLE || output_format == OUT_NUSHELL) {
        msgpack_buf = malloc(header.msgpack_buffer_size);
        if (!msgpack_buf) {
            perror("malloc");
            return false;
        }
    }

    return true;
}

// --------------------------------------------------------------------------
// Cache directory management
// --------------------------------------------------------------------------

// Get cache directory path
static char *get_cache_dir(void) {
    // Check for custom cache directory
    const char *custom = getenv("FAST_COMPLETER_CACHE");
    if (custom && *custom) {
        return strdup(custom);
    }

    // Fall back to platform-specific default
    char *dir = NULL;

#ifdef _WIN32
    const char *localappdata = getenv("LOCALAPPDATA");
    if (localappdata) {
        size_t len = strlen(localappdata) + 20;
        dir = malloc(len);
        snprintf(dir, len, "%s\\fast-completer", localappdata);
    }
#else
    const char *home = getenv("HOME");
    if (home) {
        size_t len = strlen(home) + 30;
        dir = malloc(len);
        snprintf(dir, len, "%s/.cache/fast-completer", home);
    }
#endif

    return dir;
}

// Create cache directory if it doesn't exist
static bool ensure_cache_dir(void) {
    char *cache_dir = get_cache_dir();
    if (!cache_dir) return false;

#ifdef _WIN32
    // Create fast-completer directory under %LOCALAPPDATA%
    CreateDirectoryA(cache_dir, NULL);
#else
    // Create ~/.cache if needed, then ~/.cache/fast-completer
    char *parent = strdup(cache_dir);
    char *last_slash = strrchr(parent, '/');
    if (last_slash) {
        *last_slash = '\0';
        mkdir(parent, 0755);
    }
    mkdir(cache_dir, 0755);
#endif

    return true;
}

// Build full blob path in cache directory
static char *build_cache_path(const char *name) {
    char *cache_dir = get_cache_dir();
    if (!cache_dir) return NULL;

    size_t len = strlen(cache_dir) + strlen(name) + 10;
    char *path = malloc(len);
#ifdef _WIN32
    snprintf(path, len, "%s\\%s.bin", cache_dir, name);
#else
    snprintf(path, len, "%s/%s.bin", cache_dir, name);
#endif

    return path;
}

// Check if path looks like a simple name (no slashes)
static bool is_simple_name(const char *path) {
    while (*path) {
        if (*path == '/' || *path == '\\') return false;
        path++;
    }
    return true;
}

// Resolve blob path: if simple name, look in cache; otherwise use as-is
static char *resolve_blob_path(const char *blob_arg) {
    // If it contains path separators or ends with .bin, use as-is
    if (!is_simple_name(blob_arg)) {
        return strdup(blob_arg);
    }

    // Strip .bin extension if present
    char *name = strdup(blob_arg);
    size_t len = strlen(name);
    if (len > 4 && strcmp(name + len - 4, ".bin") == 0) {
        name[len - 4] = '\0';
    }

    char *path = build_cache_path(name);
    return path;
}

// Dump blob header for debugging
static void dump_header(const char *path) {
    const uint32_t *h = (const uint32_t *)(blob + 8);
    uint16_t version = *(uint16_t *)(blob + 4);
    uint16_t flags = *(uint16_t *)(blob + 6);

    printf("path: %s\n", path);
    printf("magic: %.4s\n", (const char *)blob);
    printf("version: %u\n", version);
    printf("flags: %u", flags);
    if (flags) {
        printf("(");
        if (flags & HEADER_FLAG_BIG_ENDIAN) printf("big_endian");
        if (flags & HEADER_FLAG_NO_DESCRIPTIONS) {
            if (flags & HEADER_FLAG_BIG_ENDIAN) printf(", ");
            printf("no_descriptions");
        }
        printf(")");
    }
    printf("\n");
    printf("max_command_path_len: %u\n", h[0]);
    printf("msgpack_buffer_size: %u\n", h[1]);
    printf("command_count: %u\n", h[2]);
    printf("param_count: %u\n", h[3]);
    printf("global_param_count: %u\n", h[4]);
    printf("string_table_size: %u\n", h[5]);
    printf("choices_count: %u\n", h[6]);
    printf("members_count: %u\n", h[7]);
    printf("string_table_off: %u\n", h[8]);
    printf("commands_off: %u\n", h[9]);
    printf("params_off: %u\n", h[10]);
    printf("choices_off: %u\n", h[11]);
    printf("members_off: %u\n", h[12]);
    printf("global_params_off: %u\n", h[13]);
    printf("root_command_off: %u\n", h[14]);
}

static void print_help(void) {
    puts("fast-completer - Universal fast completion provider\n");
    puts("Usage: fast-completer [options] <format> <spans...>");
    puts("       fast-completer --generate-blob <schema> [output]");
    puts("       fast-completer --dump-header <blob>\n");
    puts("Completion mode:");
    puts("  fast-completer [options] <format> <spans...>\n");
    puts("  format        Output format (see below)");
    puts("  spans         Command line tokens starting with CLI name\n");
    puts("  --blob <path> Use blob at specified path instead of cache lookup");
    puts("  --add-space   Append trailing space to completion values\n");
    puts("  The CLI name is derived from the first span and used to look up");
    puts("  <name>.bin in the cache directory.\n");
    puts("  Cache location (override with FAST_COMPLETER_CACHE env var):");
#ifdef _WIN32
    puts("    %LOCALAPPDATA%\\fast-completer\\<name>.bin");
#else
    puts("    ~/.cache/fast-completer/<name>.bin");
#endif
    puts("");
    puts("Blob generation mode:");
    puts("  fast-completer --generate-blob [options] <schema> [output]\n");
    puts("  schema              Path to JSON schema file");
    puts("  output              Output path (optional - defaults to cache directory)");
    puts("  --big-endian        Generate big-endian blob");
    puts("  --no-descriptions   Omit descriptions entirely (smallest blob)");
    puts("  --long-descriptions Include full descriptions (default is first sentence)\n");
    puts("  If output is omitted, reads 'name' from schema and saves to cache.\n");
    puts("Dump header mode:");
    puts("  fast-completer --dump-header <blob>\n");
    puts("  blob              Path or cache name (e.g., 'aws' or '/path/to/aws.bin')\n");
    puts("Output formats:");
    puts("  bash, lines       One value per line (no descriptions)");
    puts("  zsh               value:description");
    puts("  fish, tsv         value\\tdescription");
    puts("  pwsh              PowerShell format");
    puts("  nushell           MessagePack with trailing spaces on values");
    puts("  msgpack           MessagePack array of maps");
    puts("  json              JSON array of objects");
    puts("  json-tuple        JSON array of tuples");
    puts("  msgpack-tuple     MessagePack array of tuples\n");
    puts("Use 'lines' format when descriptions are not needed.\n");
    puts("Examples:");
    puts("  fast-completer --generate-blob aws.json");
    puts("      Generate blob from schema with {\"name\": \"aws\", ...}\n");
    puts("  fast-completer bash aws s3 \"\"");
    puts("      Complete subcommands after 'aws s3'\n");
    puts("  fast-completer --blob /path/to/custom.bin zsh mycli --");
    puts("      Complete flags using explicit blob path\n");
    puts("  fast-completer --dump-header aws");
    puts("      Dump header of cached aws.bin blob");
}

int main(int argc, char *argv[]) {
    if (argc >= 2 && (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0)) {
        print_help();
        return 0;
    }

    // Handle --dump-header mode
    if (argc >= 2 && strcmp(argv[1], "--dump-header") == 0) {
        if (argc < 3) {
            fprintf(stderr, "Usage: fast-completer --dump-header <blob>\n");
            return 1;
        }
        char *path = resolve_blob_path(argv[2]);
        if (!load_blob(path)) {
            return 1;
        }
        dump_header(path);
        return 0;
    }

    // Handle --generate-blob mode (must come first)
    if (argc >= 2 && strcmp(argv[1], "--generate-blob") == 0) {
        bool big_endian = false;
        bool no_descriptions = false;
        bool long_descriptions = false;
        int arg_idx = 2;

        // Parse options
        while (argc > arg_idx && argv[arg_idx][0] == '-') {
            if (strcmp(argv[arg_idx], "--big-endian") == 0) {
                big_endian = true;
            } else if (strcmp(argv[arg_idx], "--no-descriptions") == 0) {
                no_descriptions = true;
            } else if (strcmp(argv[arg_idx], "--long-descriptions") == 0) {
                long_descriptions = true;
            } else {
                break;
            }
            arg_idx++;
        }

        if (argc < arg_idx + 1) {
            fprintf(stderr, "Usage: fast-completer --generate-blob [options] <schema> [output]\n");
            fprintf(stderr, "Options: --big-endian, --no-descriptions, --long-descriptions\n");
            return 1;
        }

        const char *schema_path = argv[arg_idx];
        const char *output_path = (argc > arg_idx + 1) ? argv[arg_idx + 1] : NULL;
        char *derived_path = NULL;

        // If no output path, derive from schema's "name" property
        if (!output_path) {
            char *name = get_schema_name(schema_path);
            if (!name) {
                fprintf(stderr, "Schema must have 'name' property when output path is omitted\n");
                return 1;
            }
            ensure_cache_dir();
            derived_path = build_cache_path(name);
            output_path = derived_path;
        }

        bool result = generate_blob(schema_path, output_path, big_endian, no_descriptions, long_descriptions);
        return result ? 0 : 1;
    }

    // Parse completion mode arguments
    int arg_idx = 1;
    const char *explicit_blob_path = NULL;

    // Check for options
    while (argc > arg_idx && argv[arg_idx][0] == '-' && argv[arg_idx][1] == '-') {
        if (argc > arg_idx + 1 && strcmp(argv[arg_idx], "--blob") == 0) {
            explicit_blob_path = argv[arg_idx + 1];
            arg_idx += 2;
        } else if (strcmp(argv[arg_idx], "--add-space") == 0) {
            add_trailing_space = true;
            arg_idx++;
        } else {
            break;
        }
    }

    if (argc < arg_idx + 2) {
        fprintf(stderr, "Usage: fast-completer [options] <format> <spans...>\n");
        fprintf(stderr, "Try 'fast-completer --help' for more information.\n");
        return 1;
    }

    const char *format_name = argv[arg_idx];
    int spans_start = arg_idx + 1;
    const char *cli_name = argv[spans_start]; // Derive from first span

    // Resolve blob path
    char *resolved_path = NULL;
    const char *blob_path;
    if (explicit_blob_path) {
        blob_path = explicit_blob_path;
    } else {
        resolved_path = resolve_blob_path(cli_name);
        blob_path = resolved_path;
    }

    output_format = parse_format(format_name);
    if (output_format == OUT_UNKNOWN) {
        fprintf(stderr, "Unknown output format: %s\n", format_name);
        fprintf(stderr, "Supported: lines, zsh, tsv, json, json-tuple, msgpack, msgpack-tuple, nushell, pwsh\n");
        return 1;
    }

    // nushell format implies --add-space
    if (output_format == OUT_NUSHELL) {
        add_trailing_space = true;
    }

    if (!load_blob(blob_path)) {
        // If cache lookup failed, show helpful error
        if (!explicit_blob_path && is_simple_name(cli_name)) {
            char *cache_dir = get_cache_dir();
            fprintf(stderr, "Blob '%s' not found in %s\n", cli_name, cache_dir ? cache_dir : "(unknown)");
            fprintf(stderr, "Generate it with: fast-completer --generate-blob <schema>\n");
        }
        return 1;
    }

    if (!alloc_buffers()) {
        return 1;
    }

    flockfile(stdout);
    complete(argc - spans_start, (const char **)(argv + spans_start));
    funlockfile(stdout);

    return 0;
}
